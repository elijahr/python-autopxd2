{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"autopxd2","text":"<p>Automatically generate Cython pxd files from C/C++ headers.</p> <p>autopxd2 parses C/C++ header files and generates Cython <code>.pxd</code> declaration files, enabling you to call C code from Python with minimal manual effort.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Full C/C++ support - Structs, enums, typedefs, functions, classes, templates, namespaces</li> <li>Macro extraction - <code>#define</code> constants as typed declarations</li> <li>Automatic imports - Generates <code>cimport</code> statements for standard library types</li> <li>Docker support - Generate headers without installing LLVM locally</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Generate pxd from a C/C++ header\nautopxd myheader.h &gt; myheader.pxd\n\n# Or use Docker without local LLVM installation\ndocker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 autopxd myheader.h\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install autopxd2\n\n# Install clang2 matching your LLVM version (recommended)\npip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre> <p>See Installation Guide for platform-specific LLVM setup.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Detailed installation options</li> <li>Quick Start - Get started in 5 minutes</li> <li>Docker Usage - Use Docker for libclang support</li> <li>Parser Backends - Choose the right backend</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to autopxd2!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>We recommend using uv for fast dependency management.</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/elijahr/python-autopxd2.git\ncd python-autopxd2\n</code></pre></p> </li> <li> <p>Create a virtual environment and install dependencies:    <pre><code># Using uv (recommended)\nuv venv\nsource .venv/bin/activate  # or `.venv\\Scripts\\activate` on Windows\nuv pip install -e '.[test,lint,docs]'\n\n# Or using pip\npython -m venv .venv\nsource .venv/bin/activate\npip install -e '.[test,lint,docs]'\n</code></pre></p> </li> <li> <p>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Run specific test file\npytest test/test_ir.py\n\n# Run tests with coverage\npytest --cov=autopxd\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use ruff for linting and formatting:</p> <pre><code># Check for issues\nruff check autopxd\n\n# Auto-fix issues\nruff check --fix autopxd\n\n# Format code\nruff format autopxd\n</code></pre> <p>Pre-commit hooks run automatically on commit to ensure consistent style.</p>"},{"location":"contributing/#type-checking","title":"Type Checking","text":"<p>We use mypy with strict mode:</p> <pre><code>mypy autopxd/ --strict\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Serve docs locally with live reload\nuv run mkdocs serve\n\n# Or without uv\nmkdocs serve\n\n# Build static site\nmkdocs build\n</code></pre> <p>The docs will be available at <code>http://127.0.0.1:8000/</code>.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/my-feature</code></li> <li>Make your changes</li> <li>Run tests: <code>pytest</code></li> <li>Run linters: <code>ruff check autopxd</code></li> <li>Run type check: <code>mypy autopxd/ --strict</code></li> <li>Commit with a clear message</li> <li>Push and create a pull request</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Please report issues on GitHub Issues.</p> <p>Include:</p> <ul> <li>Python version</li> <li>Operating system</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Relevant error messages or output</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section documents the public Python API for autopxd2.</p>"},{"location":"api/#modules","title":"Modules","text":""},{"location":"api/#ir-module","title":"IR Module","text":"<p>The Intermediate Representation (IR) module defines data structures for representing C/C++ constructs:</p> <ul> <li><code>Header</code> - Top-level container for parsed declarations</li> <li><code>Struct</code>, <code>Enum</code>, <code>Function</code>, <code>Typedef</code>, <code>Variable</code> - Declaration types</li> <li><code>CType</code>, <code>Pointer</code>, <code>Array</code>, <code>FunctionPointer</code> - Type representations</li> </ul>"},{"location":"api/#backends","title":"Backends","text":"<p>Parser backend implementations:</p> <ul> <li><code>PycparserBackend</code> - Pure Python C99 parser</li> <li><code>LibclangBackend</code> - LLVM clang-based parser with C++ support</li> </ul>"},{"location":"api/#quick-example","title":"Quick Example","text":"<pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir_writer import write_pxd\n\n# Parse a header\nbackend = get_backend()  # Uses default (pycparser)\nwith open(\"myheader.h\") as f:\n    code = f.read()\n\nheader = backend.parse(code, \"myheader.h\")\n\n# Generate pxd output\npxd = write_pxd(header)\nprint(pxd)\n</code></pre>"},{"location":"api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/#inspecting-parsed-declarations","title":"Inspecting Parsed Declarations","text":"<pre><code>from autopxd.ir import Struct, Function\n\nheader = backend.parse(code, \"header.h\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Struct):\n        print(f\"Struct: {decl.name}\")\n        for field in decl.fields:\n            print(f\"  {field.name}: {field.type}\")\n    elif isinstance(decl, Function):\n        print(f\"Function: {decl.name}\")\n        print(f\"  Returns: {decl.return_type}\")\n</code></pre>"},{"location":"api/#choosing-a-backend","title":"Choosing a Backend","text":"<pre><code>from autopxd.backends import get_backend, list_backends\n\n# List available backends\nprint(list_backends())  # ['pycparser', 'libclang']\n\n# Get a specific backend\nbackend = get_backend(\"libclang\")\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":"<p>Parser backends convert C/C++ source code into the autopxd IR.</p>"},{"location":"api/backends/#backend-registry","title":"Backend Registry","text":""},{"location":"api/backends/#autopxd.backends","title":"<code>backends</code>","text":"<p>Parser backends for autopxd.</p> <p>This package contains parser backend implementations that convert C/C++ source code into the autopxd IR (Intermediate Representation).</p>"},{"location":"api/backends/#autopxd.backends--available-backends","title":"Available Backends","text":"<p>pycparser     Pure Python C99 parser. Default backend with no external dependencies.     Requires preprocessed input (CPP/clang -E output).</p> <p>libclang     LLVM clang-based parser with full C++ support. Requires system     libclang library and matching <code>clang2</code> Python package.</p>"},{"location":"api/backends/#autopxd.backends--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends import get_backend, list_backends\n\n# Get the default backend\nbackend = get_backend()\n\n# Get a specific backend\nbackend = get_backend(\"libclang\")\n\n# List available backends\nfor name in list_backends():\n    print(name)\n</code></pre>"},{"location":"api/backends/#autopxd.backends.get_backend","title":"<code>get_backend(name=None)</code>","text":"<p>Get a parser backend instance.</p> <p>Returns a new instance of the requested backend. If no name is provided, returns the default backend (pycparser).</p> <p>::</p> <pre><code>from autopxd.backends import get_backend\n\n# Get default backend\nbackend = get_backend()\n\n# Get libclang backend\nclang = get_backend(\"libclang\")\n\n# Parse a header\nheader = backend.parse(code, \"myheader.h\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Backend name (e.g., <code>\"pycparser\"</code>, <code>\"libclang\"</code>), or None for the default backend.</p> <code>None</code> <p>Returns:</p> Type Description <code>ParserBackend</code> <p>New instance of the requested backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested backend is not available.  Example -------</p>"},{"location":"api/backends/#autopxd.backends.list_backends","title":"<code>list_backends()</code>","text":"<p>List names of all registered backends.</p> <p>::</p> <pre><code>from autopxd.backends import list_backends\n\nfor name in list_backends():\n    print(f\"Available: {name}\")\n</code></pre> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of backend names that can be passed to :func:<code>get_backend</code>.  Example -------</p>"},{"location":"api/backends/#autopxd.backends.register_backend","title":"<code>register_backend(name, backend_class, is_default=False)</code>","text":"<p>Register a parser backend.</p> <p>Called by backend modules during import to add themselves to the registry. The first registered backend becomes the default unless <code>is_default</code> is explicitly set on a later registration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique name for the backend (e.g., <code>\"pycparser\"</code>, <code>\"libclang\"</code>).</p> required <code>backend_class</code> <code>type[ParserBackend]</code> <p>Class implementing the :class:<code>~autopxd.ir.ParserBackend</code> protocol.</p> required <code>is_default</code> <code>bool</code> <p>If True, this becomes the default backend for :func:<code>get_backend</code>.</p> <code>False</code>"},{"location":"api/backends/#pycparser-backend","title":"pycparser Backend","text":""},{"location":"api/backends/#autopxd.backends.pycparser_backend","title":"<code>pycparser_backend</code>","text":"<p>pycparser-based parser backend.</p> <p>This backend uses pycparser (pure Python C99 parser) to parse C header files. It's the default backend since it requires no external dependencies beyond the pycparser package itself.</p>"},{"location":"api/backends/#autopxd.backends.pycparser_backend--limitations","title":"Limitations","text":"<ul> <li>C99 only - no C++ support (use libclang for C++)</li> <li>Cannot extract <code>#define</code> macro values (processed by preprocessor)</li> </ul>"},{"location":"api/backends/#autopxd.backends.pycparser_backend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.pycparser_backend import PycparserBackend\n\nbackend = PycparserBackend()\nheader = backend.parse(code, \"myheader.h\")\n</code></pre>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend","title":"<code>PycparserBackend</code>","text":"<p>Parser backend using pycparser.</p> <p>The default autopxd parser backend, using the pure-Python pycparser library. This backend has no external dependencies but requires preprocessed C code as input.</p>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend--properties","title":"Properties","text":"<p>name : str     Returns <code>\"pycparser\"</code>. supports_macros : bool     Returns <code>False</code> - macros are consumed by the preprocessor. supports_cpp : bool     Returns <code>False</code> - pycparser only supports C99.</p>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.pycparser_backend import PycparserBackend\n\nbackend = PycparserBackend()\n\n# Parse preprocessed code\npreprocessed = run_cpp(\"myheader.h\")\nheader = backend.parse(preprocessed, \"myheader.h\")\n\nfor decl in header.declarations:\n    print(decl)\n</code></pre> Source code in <code>autopxd/backends/pycparser_backend.py</code> <pre><code>class PycparserBackend:\n    \"\"\"Parser backend using pycparser.\n\n    The default autopxd parser backend, using the pure-Python pycparser\n    library. This backend has no external dependencies but requires\n    preprocessed C code as input.\n\n    Properties\n    ----------\n    name : str\n        Returns ``\"pycparser\"``.\n    supports_macros : bool\n        Returns ``False`` - macros are consumed by the preprocessor.\n    supports_cpp : bool\n        Returns ``False`` - pycparser only supports C99.\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends.pycparser_backend import PycparserBackend\n\n        backend = PycparserBackend()\n\n        # Parse preprocessed code\n        preprocessed = run_cpp(\"myheader.h\")\n        header = backend.parse(preprocessed, \"myheader.h\")\n\n        for decl in header.declarations:\n            print(decl)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return \"pycparser\"\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        return False\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        return False\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n    ) -&gt; Header:\n        \"\"\"Parse C code using pycparser.\n\n        The code is automatically preprocessed using the system's C preprocessor\n        (``cpp`` on Unix/Mac, ``clang -E`` on macOS, or ``cl.exe /E`` on Windows).\n\n        :param code: C source code to parse.\n        :param filename: Source filename for error messages and location tracking.\n        :param include_dirs: Additional include directories for the preprocessor.\n        :param extra_args: Extra arguments to pass to the preprocessor.\n        :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n        :raises RuntimeError: If preprocessing fails.\n        :raises pycparser.plyparser.ParseError: If the code has syntax errors.\n        \"\"\"\n        # pylint: disable=import-outside-toplevel\n        from pycparser import (\n            c_parser,\n        )\n\n        # Preprocess the code\n        preprocessed = self._preprocess(code, include_dirs, extra_args)\n\n        parser = c_parser.CParser()\n        ast = parser.parse(preprocessed, filename=filename)\n\n        converter = ASTConverter(filename)\n        return converter.convert(ast)\n\n    def _preprocess(\n        self,\n        code: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n    ) -&gt; str:\n        \"\"\"Preprocess C code using the system's C preprocessor.\n\n        :param code: C source code to preprocess.\n        :param include_dirs: Additional include directories.\n        :param extra_args: Extra preprocessor arguments (e.g., -DFOO=1).\n        :returns: Preprocessed code.\n        :raises RuntimeError: If preprocessing fails.\n        \"\"\"\n        if include_dirs is None:\n            include_dirs = []\n        if extra_args is None:\n            extra_args = []\n\n        # Build include paths\n        includes: list[str] = []\n        if platform.system() == \"Darwin\":\n            cmd = [\"clang\", \"-E\"]\n            includes.append(str(DARWIN_HEADERS_DIR))\n        else:\n            cmd = [\"cpp\"]\n        includes.append(str(BUILTIN_HEADERS_DIR))\n\n        # Build command\n        cmd += [f\"-I{inc}\" for inc in includes]\n        cmd += [\"-nostdinc\", \"-iquote\"]\n        cmd += [f\"-I{inc}\" for inc in includes]\n        cmd += [\n            \"-D__attribute__(x)=\",\n            \"-D__extension__=\",\n            \"-D__inline=\",\n            \"-D__asm=\",\n        ]\n        # Add user-specified include dirs\n        for inc in include_dirs:\n            cmd.append(f\"-I{inc}\")\n        cmd += extra_args\n        cmd.append(\"-\")\n\n        with subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        ) as proc:\n            stdout, stderr = proc.communicate(input=code.encode(\"utf-8\"))\n            if proc.returncode != 0:\n                raise RuntimeError(\n                    f\"C preprocessor failed (exit {proc.returncode}): \" f\"{stderr.decode('utf-8', errors='replace')}\"\n                )\n\n        result = stdout.decode(\"utf-8\")\n        return result.replace(\"\\r\\n\", \"\\n\")\n</code></pre>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend.parse","title":"<code>parse(code, filename, include_dirs=None, extra_args=None)</code>","text":"<p>Parse C code using pycparser.</p> <p>The code is automatically preprocessed using the system's C preprocessor (<code>cpp</code> on Unix/Mac, <code>clang -E</code> on macOS, or <code>cl.exe /E</code> on Windows).</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>C source code to parse.</p> required <code>filename</code> <code>str</code> <p>Source filename for error messages and location tracking.</p> required <code>include_dirs</code> <code>list[str] | None</code> <p>Additional include directories for the preprocessor.</p> <code>None</code> <code>extra_args</code> <code>list[str] | None</code> <p>Extra arguments to pass to the preprocessor.</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>:class:<code>~autopxd.ir.Header</code> containing parsed declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If preprocessing fails.</p> <code>pycparser.plyparser.ParseError</code> <p>If the code has syntax errors.</p> Source code in <code>autopxd/backends/pycparser_backend.py</code> <pre><code>def parse(\n    self,\n    code: str,\n    filename: str,\n    include_dirs: list[str] | None = None,\n    extra_args: list[str] | None = None,\n) -&gt; Header:\n    \"\"\"Parse C code using pycparser.\n\n    The code is automatically preprocessed using the system's C preprocessor\n    (``cpp`` on Unix/Mac, ``clang -E`` on macOS, or ``cl.exe /E`` on Windows).\n\n    :param code: C source code to parse.\n    :param filename: Source filename for error messages and location tracking.\n    :param include_dirs: Additional include directories for the preprocessor.\n    :param extra_args: Extra arguments to pass to the preprocessor.\n    :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n    :raises RuntimeError: If preprocessing fails.\n    :raises pycparser.plyparser.ParseError: If the code has syntax errors.\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n    from pycparser import (\n        c_parser,\n    )\n\n    # Preprocess the code\n    preprocessed = self._preprocess(code, include_dirs, extra_args)\n\n    parser = c_parser.CParser()\n    ast = parser.parse(preprocessed, filename=filename)\n\n    converter = ASTConverter(filename)\n    return converter.convert(ast)\n</code></pre>"},{"location":"api/backends/#libclang-backend","title":"libclang Backend","text":""},{"location":"api/backends/#autopxd.backends.libclang_backend","title":"<code>libclang_backend</code>","text":"<p>libclang-based parser backend.</p> <p>This backend uses libclang (LLVM's C/C++ parser) to parse header files. It provides full C/C++ support including templates, namespaces, and classes.</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend--requirements","title":"Requirements","text":"<ul> <li>System libclang library must be installed</li> <li>Python clang2 bindings version must match system libclang version   (e.g., <code>clang2==18.*</code> for LLVM 18)</li> </ul> <p>If system libclang is not available, autopxd2 automatically falls back to the pycparser backend (C99 only).</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend--advantages-over-pycparser","title":"Advantages over pycparser","text":"<ul> <li>Full C++ support (classes, templates, namespaces)</li> <li>Handles complex preprocessor constructs</li> <li>Uses the same parser as production compilers</li> <li>Better error messages with source locations</li> </ul>"},{"location":"api/backends/#autopxd.backends.libclang_backend--limitations","title":"Limitations","text":"<ul> <li>Macro extraction is limited due to Python bindings constraints</li> <li>Requires system libclang installation</li> </ul>"},{"location":"api/backends/#autopxd.backends.libclang_backend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.libclang_backend import LibclangBackend\n\nbackend = LibclangBackend()\nheader = backend.parse(code, \"myheader.hpp\", extra_args=[\"-std=c++17\"])\n</code></pre>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend","title":"<code>LibclangBackend</code>","text":"<p>Parser backend using libclang.</p> <p>Uses LLVM's libclang to parse C and C++ code. This backend supports the full C++ language including templates, classes, and namespaces.</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend--properties","title":"Properties","text":"<p>name : str     Returns <code>\"libclang\"</code>. supports_macros : bool     Returns <code>False</code> - macro extraction is limited in Python bindings. supports_cpp : bool     Returns <code>True</code> - full C++ support.</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.libclang_backend import LibclangBackend\n\nbackend = LibclangBackend()\n\n# Parse C++ code with specific standard\nheader = backend.parse(\n    code,\n    \"myheader.hpp\",\n    extra_args=[\"-std=c++17\", \"-DDEBUG=1\"]\n)\n</code></pre> Source code in <code>autopxd/backends/libclang_backend.py</code> <pre><code>class LibclangBackend:\n    \"\"\"Parser backend using libclang.\n\n    Uses LLVM's libclang to parse C and C++ code. This backend supports\n    the full C++ language including templates, classes, and namespaces.\n\n    Properties\n    ----------\n    name : str\n        Returns ``\"libclang\"``.\n    supports_macros : bool\n        Returns ``False`` - macro extraction is limited in Python bindings.\n    supports_cpp : bool\n        Returns ``True`` - full C++ support.\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends.libclang_backend import LibclangBackend\n\n        backend = LibclangBackend()\n\n        # Parse C++ code with specific standard\n        header = backend.parse(\n            code,\n            \"myheader.hpp\",\n            extra_args=[\"-std=c++17\", \"-DDEBUG=1\"]\n        )\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._index: clang.cindex.Index | None = None\n        # Cache for parsed headers (path -&gt; Header) to avoid re-parsing\n        self._parse_cache: dict[str, Header] = {}\n        # Visited set to prevent circular includes\n        self._visited: set[str] = set()\n\n    @property\n    def name(self) -&gt; str:\n        return \"libclang\"\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        # Supports simple numeric macros (#define NAME 123)\n        # Complex macros (expressions, function-like) are not supported\n        return True\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        return True\n\n    def _get_index(self) -&gt; \"clang.cindex.Index\":\n        \"\"\"Get or create the clang index.\"\"\"\n        if self._index is None:\n            self._index = clang.cindex.Index.create()\n        return self._index\n\n    def _resolve_include_path(\n        self,\n        include_path: str,\n        base_dir: str,\n        include_dirs: list[str],\n    ) -&gt; str | None:\n        \"\"\"Resolve an include path to an absolute path.\n\n        :param include_path: The include path as it appears in the header\n        :param base_dir: Directory of the including file\n        :param include_dirs: List of include search directories\n        :returns: Absolute path to the header file, or None if not found\n        \"\"\"\n        # If already absolute, return as-is\n        if os.path.isabs(include_path):\n            if os.path.exists(include_path):\n                return os.path.abspath(include_path)\n            return None\n\n        # Try relative to base directory first\n        candidate = os.path.join(base_dir, include_path)\n        if os.path.exists(candidate):\n            return os.path.abspath(candidate)\n\n        # Try each include directory\n        for inc_dir in include_dirs:\n            candidate = os.path.join(inc_dir, include_path)\n            if os.path.exists(candidate):\n                return os.path.abspath(candidate)\n\n        return None\n\n    def _parse_header_file(\n        self,\n        header_path: str,\n        include_dirs: list[str],\n        extra_args: list[str],\n        use_default_includes: bool,\n    ) -&gt; Header:\n        \"\"\"Parse a single header file.\n\n        :param header_path: Absolute path to header file\n        :param include_dirs: Include directories\n        :param extra_args: Extra compiler arguments\n        :param use_default_includes: Whether to use system includes\n        :returns: Parsed Header IR\n        \"\"\"\n        # Check cache\n        if header_path in self._parse_cache:\n            return self._parse_cache[header_path]\n\n        # Read the file\n        with open(header_path, encoding=\"utf-8\", errors=\"replace\") as f:\n            code = f.read()\n\n        # Parse using the main parse method\n        # Use the basename for the filename to match expected behavior\n        filename = os.path.basename(header_path)\n        header = self.parse(\n            code,\n            filename,\n            include_dirs=include_dirs,\n            extra_args=extra_args,\n            use_default_includes=use_default_includes,\n            recursive_includes=False,  # Prevent infinite recursion\n        )\n\n        # Cache the result\n        self._parse_cache[header_path] = header\n        return header\n\n    def _parse_recursively(\n        self,\n        main_header: Header,\n        main_path: str,\n        include_dirs: list[str],\n        extra_args: list[str],\n        use_default_includes: bool,\n        max_depth: int,\n        current_depth: int = 0,\n        project_prefixes: tuple[str, ...] | None = None,\n    ) -&gt; Header:\n        \"\"\"Recursively parse included headers and combine declarations.\n\n        :param main_header: The main header that was parsed\n        :param main_path: Path to the main header file\n        :param include_dirs: Include directories\n        :param extra_args: Extra compiler arguments\n        :param use_default_includes: Whether to use system includes\n        :param max_depth: Maximum recursion depth\n        :param current_depth: Current recursion depth\n        :param project_prefixes: Optional tuple of path prefixes to treat as project (not system)\n        :returns: Combined Header with declarations from all includes\n        \"\"\"\n        if current_depth &gt;= max_depth:\n            return main_header\n\n        all_declarations: list[Declaration] = list(main_header.declarations)\n        main_dir = os.path.dirname(os.path.abspath(main_path))\n\n        # Process each included header\n        for include_path in main_header.included_headers:\n            # Skip system headers (unless whitelisted via project_prefixes)\n            if _is_system_header(include_path, project_prefixes):\n                continue\n\n            # Get absolute path\n            abs_path = self._resolve_include_path(\n                include_path,\n                main_dir,\n                include_dirs,\n            )\n\n            if abs_path is None:\n                # Could not resolve - skip\n                continue\n\n            # Check if already visited (circular include)\n            if abs_path in self._visited:\n                continue\n\n            self._visited.add(abs_path)\n\n            try:\n                # Parse the included header\n                sub_header = self._parse_header_file(\n                    abs_path,\n                    include_dirs,\n                    extra_args,\n                    use_default_includes,\n                )\n\n                # Recursively process its includes\n                sub_header = self._parse_recursively(\n                    sub_header,\n                    abs_path,\n                    include_dirs,\n                    extra_args,\n                    use_default_includes,\n                    max_depth,\n                    current_depth + 1,\n                    project_prefixes,\n                )\n\n                # Add declarations from sub-header\n                all_declarations.extend(sub_header.declarations)\n\n            except Exception:\n                # Skip headers that fail to parse\n                # This is common with complex system headers\n                continue\n\n        # Deduplicate declarations\n        unique_declarations = _deduplicate_declarations(all_declarations)\n\n        # Return combined header\n        return Header(\n            path=main_header.path,\n            declarations=unique_declarations,\n            included_headers=main_header.included_headers,\n        )\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n        use_default_includes: bool = True,\n        recursive_includes: bool = True,\n        max_depth: int = 10,\n        project_prefixes: tuple[str, ...] | None = None,\n    ) -&gt; Header:\n        \"\"\"Parse C/C++ code using libclang.\n\n        Unlike the pycparser backend, this method handles raw (unpreprocessed)\n        code and performs preprocessing internally.\n\n        Umbrella header support: If the header has few/no declarations but many\n        includes (umbrella header pattern), this method can recursively parse the\n        included headers and combine their declarations.\n\n        :param code: C/C++ source code to parse (raw, not preprocessed).\n        :param filename: Source filename for error messages and location tracking.\n        :param include_dirs: Additional include directories (converted to ``-I`` flags).\n        :param extra_args: Additional compiler arguments (e.g., ``[\"-std=c++17\"]``).\n        :param use_default_includes: If True (default), automatically detect and add\n            system include directories by querying the system clang compiler.\n            Set to False to disable this behavior.\n        :param recursive_includes: If True (default), detect umbrella headers and\n            recursively parse included project headers. System headers are always\n            skipped. Set to False to only parse the main file.\n        :param max_depth: Maximum recursion depth for include processing (default 10).\n            Prevents infinite recursion from circular includes.\n        :param project_prefixes: Optional tuple of path prefixes to treat as project\n            headers (not system). Use this for umbrella headers of libraries installed\n            in system locations (e.g., ``(\"/opt/homebrew/include/sodium\",)``).\n        :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n        :raises RuntimeError: If parsing fails with errors.\n\n        Example\n        -------\n        ::\n\n            # Basic usage\n            header = backend.parse(\n                code,\n                \"myheader.hpp\",\n                include_dirs=[\"/usr/local/include\"],\n                extra_args=[\"-std=c++17\", \"-DNDEBUG\"]\n            )\n\n            # Umbrella header (all-includes) pattern\n            header = backend.parse(\n                code,\n                \"LibraryAll.h\",\n                include_dirs=[\"./include\"],\n                recursive_includes=True  # Auto-detect and expand includes\n            )\n\n            # Umbrella header in system location\n            header = backend.parse(\n                code,\n                \"sodium.h\",\n                include_dirs=[\"/opt/homebrew/include\"],\n                project_prefixes=(\"/opt/homebrew/include/sodium\",)  # Whitelist sodium/*\n            )\n        \"\"\"\n        args: list[str] = []\n\n        # Detect C++ mode from extra_args\n        is_cplus = bool(extra_args and any(arg in (\"-x\", \"c++\") or arg.startswith(\"-std=c++\") for arg in extra_args))\n\n        # Add user-specified include directories FIRST\n        # This is important for C++ where user headers may need to come before system libc++\n        if include_dirs:\n            for inc_dir in include_dirs:\n                args.append(f\"-I{inc_dir}\")\n\n        # Add system include directories if enabled\n        # Always add them when use_default_includes=True, regardless of other -I flags\n        if use_default_includes:\n            args.extend(get_system_include_dirs(cplus=is_cplus))\n\n        # Add extra arguments\n        if extra_args:\n            args.extend(extra_args)\n\n        # Parse the code with detailed preprocessing record for macro extraction\n        index = self._get_index()\n        tu = index.parse(\n            filename,\n            args=args,\n            unsaved_files=[(filename, code)],\n            options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD,\n        )\n\n        # Check for fatal errors\n        for diag in tu.diagnostics:\n            if diag.severity &gt;= clang.cindex.Diagnostic.Error:\n                raise RuntimeError(f\"Parse error: {diag.spelling}\")\n\n        # Collect included headers\n        included_headers: set[str] = set()\n        for inclusion in tu.get_includes():\n            # inclusion.include is a File with name attribute\n            header_path = str(inclusion.include.name)\n            # Store full path - caller can extract basename if needed\n            included_headers.add(header_path)\n\n        # Convert to IR\n        converter = ClangASTConverter(filename, project_prefixes=project_prefixes)\n        header = converter.convert(tu)\n\n        # Attach included headers to the IR\n        header.included_headers = included_headers\n\n        # Check if we should do recursive include processing\n        if recursive_includes and _is_umbrella_header(header, project_prefixes=project_prefixes):\n            # Reset visited set for each top-level parse\n            self._visited = set()\n            # Add current file to visited\n            if os.path.exists(filename):\n                abs_filename = os.path.abspath(filename)\n            else:\n                # For in-memory code, use filename as-is\n                abs_filename = filename\n            self._visited.add(abs_filename)\n\n            # Recursively parse included headers\n            header = self._parse_recursively(\n                header,\n                abs_filename,\n                include_dirs or [],\n                extra_args or [],\n                use_default_includes,\n                max_depth,\n                project_prefixes=project_prefixes,\n            )\n\n        return header\n</code></pre>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend.parse","title":"<code>parse(code, filename, include_dirs=None, extra_args=None, use_default_includes=True, recursive_includes=True, max_depth=10, project_prefixes=None)</code>","text":"<p>Parse C/C++ code using libclang.</p> <p>Unlike the pycparser backend, this method handles raw (unpreprocessed) code and performs preprocessing internally.</p> <p>Umbrella header support: If the header has few/no declarations but many includes (umbrella header pattern), this method can recursively parse the included headers and combine their declarations.</p> <p>::</p> <pre><code># Basic usage\nheader = backend.parse(\n    code,\n    \"myheader.hpp\",\n    include_dirs=[\"/usr/local/include\"],\n    extra_args=[\"-std=c++17\", \"-DNDEBUG\"]\n)\n\n# Umbrella header (all-includes) pattern\nheader = backend.parse(\n    code,\n    \"LibraryAll.h\",\n    include_dirs=[\"./include\"],\n    recursive_includes=True  # Auto-detect and expand includes\n)\n\n# Umbrella header in system location\nheader = backend.parse(\n    code,\n    \"sodium.h\",\n    include_dirs=[\"/opt/homebrew/include\"],\n    project_prefixes=(\"/opt/homebrew/include/sodium\",)  # Whitelist sodium/*\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>C/C++ source code to parse (raw, not preprocessed).</p> required <code>filename</code> <code>str</code> <p>Source filename for error messages and location tracking.</p> required <code>include_dirs</code> <code>list[str] | None</code> <p>Additional include directories (converted to <code>-I</code> flags).</p> <code>None</code> <code>extra_args</code> <code>list[str] | None</code> <p>Additional compiler arguments (e.g., <code>[\"-std=c++17\"]</code>).</p> <code>None</code> <code>use_default_includes</code> <code>bool</code> <p>If True (default), automatically detect and add system include directories by querying the system clang compiler. Set to False to disable this behavior.</p> <code>True</code> <code>recursive_includes</code> <code>bool</code> <p>If True (default), detect umbrella headers and recursively parse included project headers. System headers are always skipped. Set to False to only parse the main file.</p> <code>True</code> <code>max_depth</code> <code>int</code> <p>Maximum recursion depth for include processing (default 10). Prevents infinite recursion from circular includes.</p> <code>10</code> <code>project_prefixes</code> <code>tuple[str, ...] | None</code> <p>Optional tuple of path prefixes to treat as project headers (not system). Use this for umbrella headers of libraries installed in system locations (e.g., <code>(\"/opt/homebrew/include/sodium\",)</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>:class:<code>~autopxd.ir.Header</code> containing parsed declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If parsing fails with errors.  Example -------</p> Source code in <code>autopxd/backends/libclang_backend.py</code> <pre><code>def parse(\n    self,\n    code: str,\n    filename: str,\n    include_dirs: list[str] | None = None,\n    extra_args: list[str] | None = None,\n    use_default_includes: bool = True,\n    recursive_includes: bool = True,\n    max_depth: int = 10,\n    project_prefixes: tuple[str, ...] | None = None,\n) -&gt; Header:\n    \"\"\"Parse C/C++ code using libclang.\n\n    Unlike the pycparser backend, this method handles raw (unpreprocessed)\n    code and performs preprocessing internally.\n\n    Umbrella header support: If the header has few/no declarations but many\n    includes (umbrella header pattern), this method can recursively parse the\n    included headers and combine their declarations.\n\n    :param code: C/C++ source code to parse (raw, not preprocessed).\n    :param filename: Source filename for error messages and location tracking.\n    :param include_dirs: Additional include directories (converted to ``-I`` flags).\n    :param extra_args: Additional compiler arguments (e.g., ``[\"-std=c++17\"]``).\n    :param use_default_includes: If True (default), automatically detect and add\n        system include directories by querying the system clang compiler.\n        Set to False to disable this behavior.\n    :param recursive_includes: If True (default), detect umbrella headers and\n        recursively parse included project headers. System headers are always\n        skipped. Set to False to only parse the main file.\n    :param max_depth: Maximum recursion depth for include processing (default 10).\n        Prevents infinite recursion from circular includes.\n    :param project_prefixes: Optional tuple of path prefixes to treat as project\n        headers (not system). Use this for umbrella headers of libraries installed\n        in system locations (e.g., ``(\"/opt/homebrew/include/sodium\",)``).\n    :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n    :raises RuntimeError: If parsing fails with errors.\n\n    Example\n    -------\n    ::\n\n        # Basic usage\n        header = backend.parse(\n            code,\n            \"myheader.hpp\",\n            include_dirs=[\"/usr/local/include\"],\n            extra_args=[\"-std=c++17\", \"-DNDEBUG\"]\n        )\n\n        # Umbrella header (all-includes) pattern\n        header = backend.parse(\n            code,\n            \"LibraryAll.h\",\n            include_dirs=[\"./include\"],\n            recursive_includes=True  # Auto-detect and expand includes\n        )\n\n        # Umbrella header in system location\n        header = backend.parse(\n            code,\n            \"sodium.h\",\n            include_dirs=[\"/opt/homebrew/include\"],\n            project_prefixes=(\"/opt/homebrew/include/sodium\",)  # Whitelist sodium/*\n        )\n    \"\"\"\n    args: list[str] = []\n\n    # Detect C++ mode from extra_args\n    is_cplus = bool(extra_args and any(arg in (\"-x\", \"c++\") or arg.startswith(\"-std=c++\") for arg in extra_args))\n\n    # Add user-specified include directories FIRST\n    # This is important for C++ where user headers may need to come before system libc++\n    if include_dirs:\n        for inc_dir in include_dirs:\n            args.append(f\"-I{inc_dir}\")\n\n    # Add system include directories if enabled\n    # Always add them when use_default_includes=True, regardless of other -I flags\n    if use_default_includes:\n        args.extend(get_system_include_dirs(cplus=is_cplus))\n\n    # Add extra arguments\n    if extra_args:\n        args.extend(extra_args)\n\n    # Parse the code with detailed preprocessing record for macro extraction\n    index = self._get_index()\n    tu = index.parse(\n        filename,\n        args=args,\n        unsaved_files=[(filename, code)],\n        options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD,\n    )\n\n    # Check for fatal errors\n    for diag in tu.diagnostics:\n        if diag.severity &gt;= clang.cindex.Diagnostic.Error:\n            raise RuntimeError(f\"Parse error: {diag.spelling}\")\n\n    # Collect included headers\n    included_headers: set[str] = set()\n    for inclusion in tu.get_includes():\n        # inclusion.include is a File with name attribute\n        header_path = str(inclusion.include.name)\n        # Store full path - caller can extract basename if needed\n        included_headers.add(header_path)\n\n    # Convert to IR\n    converter = ClangASTConverter(filename, project_prefixes=project_prefixes)\n    header = converter.convert(tu)\n\n    # Attach included headers to the IR\n    header.included_headers = included_headers\n\n    # Check if we should do recursive include processing\n    if recursive_includes and _is_umbrella_header(header, project_prefixes=project_prefixes):\n        # Reset visited set for each top-level parse\n        self._visited = set()\n        # Add current file to visited\n        if os.path.exists(filename):\n            abs_filename = os.path.abspath(filename)\n        else:\n            # For in-memory code, use filename as-is\n            abs_filename = filename\n        self._visited.add(abs_filename)\n\n        # Recursively parse included headers\n        header = self._parse_recursively(\n            header,\n            abs_filename,\n            include_dirs or [],\n            extra_args or [],\n            use_default_includes,\n            max_depth,\n            project_prefixes=project_prefixes,\n        )\n\n    return header\n</code></pre>"},{"location":"api/ir/","title":"IR Module","text":"<p>The IR (Intermediate Representation) module provides data structures for representing C/C++ declarations in a parser-agnostic format.</p>"},{"location":"api/ir/#autopxd.ir","title":"<code>ir</code>","text":"<p>Intermediate Representation (IR) for C/C++ declarations.</p> <p>This module defines the IR that all parser backends produce. The writer consumes this IR to generate Cython <code>.pxd</code> files.</p>"},{"location":"api/ir/#autopxd.ir--design-principles","title":"Design Principles","text":"<ul> <li>Parser-agnostic: Works with pycparser, libclang, tree-sitter, etc.</li> <li>Intuitive composition: Types compose naturally   (e.g., <code>const char*</code> becomes <code>Pointer(CType(\"char\", [\"const\"]))</code>)</li> <li>Complete coverage: Represents everything Cython <code>.pxd</code> files can express</li> </ul>"},{"location":"api/ir/#autopxd.ir--type-hierarchy","title":"Type Hierarchy","text":"<p>Type expressions form a recursive structure:</p> <ul> <li>:class:<code>CType</code> - Base C type (<code>int</code>, <code>unsigned long</code>, etc.)</li> <li>:class:<code>Pointer</code> - Pointer to another type (<code>int*</code>, <code>char**</code>)</li> <li>:class:<code>Array</code> - Fixed or flexible array (<code>int[10]</code>, <code>char[]</code>)</li> <li>:class:<code>FunctionPointer</code> - Function pointer type</li> </ul>"},{"location":"api/ir/#autopxd.ir--declaration-types","title":"Declaration Types","text":"<ul> <li>:class:<code>Enum</code> - Enumeration with named constants</li> <li>:class:<code>Struct</code> - Struct or union with fields</li> <li>:class:<code>Function</code> - Function declaration</li> <li>:class:<code>Typedef</code> - Type alias</li> <li>:class:<code>Variable</code> - Global variable</li> <li>:class:<code>Constant</code> - Compile-time constant or macro</li> </ul>"},{"location":"api/ir/#autopxd.ir--example","title":"Example","text":"<p>Parse a header and inspect declarations::</p> <pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir import Struct, Function\n\nbackend = get_backend()\nheader = backend.parse(\"struct Point { int x; int y; };\", \"test.h\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Struct):\n        print(f\"Found struct: {decl.name}\")\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Header","title":"<code>Header</code>  <code>dataclass</code>","text":"<p>Container for a parsed C/C++ header file.</p> <p>This is the top-level result returned by all parser backends. It contains the file path and all extracted declarations.</p> <p>::</p> <pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir import Struct, Function\n\nbackend = get_backend()\nheader = backend.parse(code, \"myheader.h\")\n\nprint(f\"Parsed {len(header.declarations)} declarations from {header.path}\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Function):\n        print(f\"  Function: {decl.name}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the original header file.</p> required <code>declarations</code> <code>list[Declaration]</code> <p>List of extracted declarations (structs, functions, etc.).</p> <code>list()</code> <code>included_headers</code> <code>set[str]</code> <p>Set of header file basenames included by this header (populated by libclang backend only).  Example -------</p> <code>set()</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Header:\n    \"\"\"Container for a parsed C/C++ header file.\n\n    This is the top-level result returned by all parser backends.\n    It contains the file path and all extracted declarations.\n\n    :param path: Path to the original header file.\n    :param declarations: List of extracted declarations (structs, functions, etc.).\n    :param included_headers: Set of header file basenames included by this header\n                             (populated by libclang backend only).\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends import get_backend\n        from autopxd.ir import Struct, Function\n\n        backend = get_backend()\n        header = backend.parse(code, \"myheader.h\")\n\n        print(f\"Parsed {len(header.declarations)} declarations from {header.path}\")\n\n        for decl in header.declarations:\n            if isinstance(decl, Function):\n                print(f\"  Function: {decl.name}\")\n    \"\"\"\n\n    path: str\n    declarations: list[Declaration] = field(default_factory=list)\n    included_headers: set[str] = field(default_factory=set)\n\n    def __str__(self) -&gt; str:\n        return f\"Header({self.path}, {len(self.declarations)} declarations)\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.CType","title":"<code>CType</code>  <code>dataclass</code>","text":"<p>A C type expression representing a base type with optional qualifiers.</p> <p>This is the fundamental building block for all type representations. Qualifiers like <code>const</code>, <code>volatile</code>, <code>unsigned</code> are stored separately from the type name for easier manipulation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The base type name (e.g., <code>\"int\"</code>, <code>\"long\"</code>, <code>\"char\"</code>).</p> required <code>qualifiers</code> <code>list[str]</code> <p>Type qualifiers (e.g., <code>[\"const\"]</code>, <code>[\"unsigned\"]</code>).  Examples -------- Simple types::  int_type = CType(\"int\") unsigned_long = CType(\"long\", [\"unsigned\"]) const_int = CType(\"int\", [\"const\"])  Composite types with pointers::  from autopxd.ir import Pointer  # const char* const_char_ptr = Pointer(CType(\"char\", [\"const\"]))</p> <code>list()</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass CType:\n    \"\"\"A C type expression representing a base type with optional qualifiers.\n\n    This is the fundamental building block for all type representations.\n    Qualifiers like ``const``, ``volatile``, ``unsigned`` are stored separately\n    from the type name for easier manipulation.\n\n    :param name: The base type name (e.g., ``\"int\"``, ``\"long\"``, ``\"char\"``).\n    :param qualifiers: Type qualifiers (e.g., ``[\"const\"]``, ``[\"unsigned\"]``).\n\n    Examples\n    --------\n    Simple types::\n\n        int_type = CType(\"int\")\n        unsigned_long = CType(\"long\", [\"unsigned\"])\n        const_int = CType(\"int\", [\"const\"])\n\n    Composite types with pointers::\n\n        from autopxd.ir import Pointer\n\n        # const char*\n        const_char_ptr = Pointer(CType(\"char\", [\"const\"]))\n    \"\"\"\n\n    name: str\n    qualifiers: list[str] = field(default_factory=list)\n\n    def __str__(self) -&gt; str:\n        if self.qualifiers:\n            return f\"{' '.join(self.qualifiers)} {self.name}\"\n        return self.name\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Pointer","title":"<code>Pointer</code>  <code>dataclass</code>","text":"<p>Pointer to another type.</p> <p>Represents pointer types with optional qualifiers. Pointers can be nested to represent multi-level indirection (e.g., <code>char**</code>).</p> <p>Parameters:</p> Name Type Description Default <code>pointee</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The type being pointed to.</p> required <code>qualifiers</code> <code>list[str]</code> <p>Qualifiers on the pointer itself (e.g., <code>[\"const\"]</code> for a const pointer, not a pointer to const).  Examples -------- Basic pointer::  int_ptr = Pointer(CType(\"int\"))  # int  Pointer to const::  const_char_ptr = Pointer(CType(\"char\", [\"const\"]))  # const char  Double pointer::  char_ptr_ptr = Pointer(Pointer(CType(\"char\")))  # char*  Const pointer (pointer itself is const)::  const_ptr = Pointer(CType(\"int\"), [\"const\"])  # int const</p> <code>list()</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Pointer:\n    \"\"\"Pointer to another type.\n\n    Represents pointer types with optional qualifiers. Pointers can be\n    nested to represent multi-level indirection (e.g., ``char**``).\n\n    :param pointee: The type being pointed to.\n    :param qualifiers: Qualifiers on the pointer itself (e.g., ``[\"const\"]``\n        for a const pointer, not a pointer to const).\n\n    Examples\n    --------\n    Basic pointer::\n\n        int_ptr = Pointer(CType(\"int\"))  # int*\n\n    Pointer to const::\n\n        const_char_ptr = Pointer(CType(\"char\", [\"const\"]))  # const char*\n\n    Double pointer::\n\n        char_ptr_ptr = Pointer(Pointer(CType(\"char\")))  # char**\n\n    Const pointer (pointer itself is const)::\n\n        const_ptr = Pointer(CType(\"int\"), [\"const\"])  # int* const\n    \"\"\"\n\n    pointee: Union[CType, Pointer, Array, FunctionPointer]\n    qualifiers: list[str] = field(default_factory=list)\n\n    def __str__(self) -&gt; str:\n        quals = f\"{' '.join(self.qualifiers)} \" if self.qualifiers else \"\"\n        return f\"{quals}{self.pointee}*\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Array","title":"<code>Array</code>  <code>dataclass</code>","text":"<p>Fixed-size or flexible array type.</p> <p>Represents C array types, which can have a fixed numeric size, a symbolic size (macro or constant), or be flexible (incomplete).</p> <p>Parameters:</p> Name Type Description Default <code>element_type</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The type of array elements.</p> required <code>size</code> <code>Optional[Union[int, str]]</code> <p>Array size - an integer for fixed size, a string for symbolic/expression size (e.g., <code>\"MAX_SIZE\"</code>), or None for flexible/incomplete arrays.  Examples -------- Fixed-size array::  int_arr = Array(CType(\"int\"), 10)  Flexible array (incomplete)::  flex_arr = Array(CType(\"char\"), None)  Symbolic size::  buf = Array(CType(\"char\"), \"BUFFER_SIZE\")  Multi-dimensional array::  matrix = Array(Array(CType(\"int\"), 3), 3)</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Array:\n    \"\"\"Fixed-size or flexible array type.\n\n    Represents C array types, which can have a fixed numeric size,\n    a symbolic size (macro or constant), or be flexible (incomplete).\n\n    :param element_type: The type of array elements.\n    :param size: Array size - an integer for fixed size, a string for\n        symbolic/expression size (e.g., ``\"MAX_SIZE\"``), or None for\n        flexible/incomplete arrays.\n\n    Examples\n    --------\n    Fixed-size array::\n\n        int_arr = Array(CType(\"int\"), 10)\n\n    Flexible array (incomplete)::\n\n        flex_arr = Array(CType(\"char\"), None)\n\n    Symbolic size::\n\n        buf = Array(CType(\"char\"), \"BUFFER_SIZE\")\n\n    Multi-dimensional array::\n\n        matrix = Array(Array(CType(\"int\"), 3), 3)\n    \"\"\"\n\n    element_type: Union[CType, Pointer, Array, FunctionPointer]\n    size: Optional[Union[int, str]] = None  # None = flexible, str = expression\n\n    def __str__(self) -&gt; str:\n        size_str = str(self.size) if self.size is not None else \"\"\n        return f\"{self.element_type}[{size_str}]\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.FunctionPointer","title":"<code>FunctionPointer</code>  <code>dataclass</code>","text":"<p>Function pointer type.</p> <p>Represents a pointer to a function with a specific signature. Used for callbacks, vtables, and function tables.</p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The function's return type.</p> required <code>parameters</code> <code>list[Parameter]</code> <p>List of function parameters.</p> <code>list()</code> <code>is_variadic</code> <code>bool</code> <p>True if the function accepts variable arguments (ends with <code>...</code>).  Examples -------- Simple function pointer::  void_fn = FunctionPointer(CType(\"int\"), [])  # int ()(void)  With parameters::  callback = FunctionPointer( CType(\"void\"), [Parameter(\"data\", Pointer(CType(\"void\")))] )  # void ()(void data)  Variadic function pointer::  printf_fn = FunctionPointer( CType(\"int\"), [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))], is_variadic=True )  # int ()(const char* fmt, ...)</p> <code>False</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass FunctionPointer:\n    \"\"\"Function pointer type.\n\n    Represents a pointer to a function with a specific signature.\n    Used for callbacks, vtables, and function tables.\n\n    :param return_type: The function's return type.\n    :param parameters: List of function parameters.\n    :param is_variadic: True if the function accepts variable arguments\n        (ends with ``...``).\n\n    Examples\n    --------\n    Simple function pointer::\n\n        void_fn = FunctionPointer(CType(\"int\"), [])  # int (*)(void)\n\n    With parameters::\n\n        callback = FunctionPointer(\n            CType(\"void\"),\n            [Parameter(\"data\", Pointer(CType(\"void\")))]\n        )  # void (*)(void* data)\n\n    Variadic function pointer::\n\n        printf_fn = FunctionPointer(\n            CType(\"int\"),\n            [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))],\n            is_variadic=True\n        )  # int (*)(const char* fmt, ...)\n    \"\"\"\n\n    return_type: Union[CType, Pointer, Array, FunctionPointer]\n    parameters: list[Parameter] = field(default_factory=list)\n    is_variadic: bool = False\n\n    def __str__(self) -&gt; str:\n        params = \", \".join(str(p) for p in self.parameters)\n        if self.is_variadic:\n            params = f\"{params}, ...\" if params else \"...\"\n        return f\"{self.return_type} (*)({params})\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Struct or union field declaration.</p> <p>Represents a single field within a struct or union definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The field name.</p> required <code>type</code> <code>TypeExpr</code> <p>The field's type expression.  Examples -------- Simple field::  x_field = Field(\"x\", CType(\"int\"))  # int x  Pointer field::  data = Field(\"data\", Pointer(CType(\"void\")))  # void* data  Array field::  buffer = Field(\"buffer\", Array(CType(\"char\"), 256))  # char buffer[256]</p> required Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Field:\n    \"\"\"Struct or union field declaration.\n\n    Represents a single field within a struct or union definition.\n\n    :param name: The field name.\n    :param type: The field's type expression.\n\n    Examples\n    --------\n    Simple field::\n\n        x_field = Field(\"x\", CType(\"int\"))  # int x\n\n    Pointer field::\n\n        data = Field(\"data\", Pointer(CType(\"void\")))  # void* data\n\n    Array field::\n\n        buffer = Field(\"buffer\", Array(CType(\"char\"), 256))  # char buffer[256]\n    \"\"\"\n\n    name: str\n    type: TypeExpr\n\n    def __str__(self) -&gt; str:\n        return f\"{self.type} {self.name}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>Function parameter declaration.</p> <p>Represents a single parameter in a function signature. Parameters may be named or anonymous (common in prototypes).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Parameter name, or None for anonymous parameters.</p> required <code>type</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The parameter's type expression.  Examples -------- Named parameter::  x_param = Parameter(\"x\", CType(\"int\"))  # int x  Anonymous parameter::  anon = Parameter(None, Pointer(CType(\"void\")))  # void*  Complex type::  callback = Parameter(\"fn\", FunctionPointer(CType(\"void\"), []))</p> required Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Parameter:\n    \"\"\"Function parameter declaration.\n\n    Represents a single parameter in a function signature. Parameters\n    may be named or anonymous (common in prototypes).\n\n    :param name: Parameter name, or None for anonymous parameters.\n    :param type: The parameter's type expression.\n\n    Examples\n    --------\n    Named parameter::\n\n        x_param = Parameter(\"x\", CType(\"int\"))  # int x\n\n    Anonymous parameter::\n\n        anon = Parameter(None, Pointer(CType(\"void\")))  # void*\n\n    Complex type::\n\n        callback = Parameter(\"fn\", FunctionPointer(CType(\"void\"), []))\n    \"\"\"\n\n    name: Optional[str]\n    type: Union[CType, Pointer, Array, FunctionPointer]\n\n    def __str__(self) -&gt; str:\n        if self.name:\n            return f\"{self.type} {self.name}\"\n        return str(self.type)\n</code></pre>"},{"location":"api/ir/#autopxd.ir.EnumValue","title":"<code>EnumValue</code>  <code>dataclass</code>","text":"<p>Single enumeration constant.</p> <p>Represents one named constant within an enum definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The constant name.</p> required <code>value</code> <code>Optional[Union[int, str]]</code> <p>The constant's value - an integer for explicit values, a string for expressions (e.g., <code>\"FOO | BAR\"</code>), or None for auto-incremented values.  Examples -------- Explicit value::  red = EnumValue(\"RED\", 0)  Auto-increment (implicit value)::  green = EnumValue(\"GREEN\", None)  # follows previous value  Expression value::  mask = EnumValue(\"MASK\", \"FLAG_A | FLAG_B\")</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass EnumValue:\n    \"\"\"Single enumeration constant.\n\n    Represents one named constant within an enum definition.\n\n    :param name: The constant name.\n    :param value: The constant's value - an integer for explicit values,\n        a string for expressions (e.g., ``\"FOO | BAR\"``), or None\n        for auto-incremented values.\n\n    Examples\n    --------\n    Explicit value::\n\n        red = EnumValue(\"RED\", 0)\n\n    Auto-increment (implicit value)::\n\n        green = EnumValue(\"GREEN\", None)  # follows previous value\n\n    Expression value::\n\n        mask = EnumValue(\"MASK\", \"FLAG_A | FLAG_B\")\n    \"\"\"\n\n    name: str\n    value: Optional[Union[int, str]] = None  # None = auto, str = expression\n\n    def __str__(self) -&gt; str:\n        if self.value is not None:\n            return f\"{self.name} = {self.value}\"\n        return self.name\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Enum","title":"<code>Enum</code>  <code>dataclass</code>","text":"<p>Enumeration declaration.</p> <p>Represents a C enum type with named constants. Enums may be named or anonymous (used in typedefs or inline).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The enum tag name, or None for anonymous enums.</p> required <code>values</code> <code>list[EnumValue]</code> <p>List of enumeration constants.</p> <code>list()</code> <code>is_typedef</code> <code>bool</code> <p>True if this enum came from a typedef declaration.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Named enum::  color = Enum(\"Color\", [ EnumValue(\"RED\", 0), EnumValue(\"GREEN\", 1), EnumValue(\"BLUE\", 2), ])  Anonymous enum (typically used with typedef)::  anon = Enum(None, [EnumValue(\"FLAG_A\", 1), EnumValue(\"FLAG_B\", 2)])</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Enum:\n    \"\"\"Enumeration declaration.\n\n    Represents a C enum type with named constants. Enums may be\n    named or anonymous (used in typedefs or inline).\n\n    :param name: The enum tag name, or None for anonymous enums.\n    :param values: List of enumeration constants.\n    :param is_typedef: True if this enum came from a typedef declaration.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Named enum::\n\n        color = Enum(\"Color\", [\n            EnumValue(\"RED\", 0),\n            EnumValue(\"GREEN\", 1),\n            EnumValue(\"BLUE\", 2),\n        ])\n\n    Anonymous enum (typically used with typedef)::\n\n        anon = Enum(None, [EnumValue(\"FLAG_A\", 1), EnumValue(\"FLAG_B\", 2)])\n    \"\"\"\n\n    name: Optional[str]\n    values: list[EnumValue] = field(default_factory=list)\n    is_typedef: bool = False\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        name_str = self.name or \"(anonymous)\"\n        return f\"enum {name_str}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Struct","title":"<code>Struct</code>  <code>dataclass</code>","text":"<p>Struct or union declaration.</p> <p>Represents a C struct or union type definition. Both use the same IR class with <code>is_union</code> distinguishing between them.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The struct/union tag name, or None for anonymous types.</p> required <code>fields</code> <code>list[Field]</code> <p>List of member fields.</p> <code>list()</code> <code>methods</code> <code>list[Function]</code> <p>List of methods (for C++ classes only).</p> <code>list()</code> <code>is_union</code> <code>bool</code> <p>True for unions, False for structs.</p> <code>False</code> <code>is_cppclass</code> <code>bool</code> <p>True for C++ classes (uses <code>cppclass</code> in Cython).</p> <code>False</code> <code>is_typedef</code> <code>bool</code> <p>True if this came from a typedef declaration.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Simple struct::  point = Struct(\"Point\", [ Field(\"x\", CType(\"int\")), Field(\"y\", CType(\"int\")), ])  Union::  data = Struct(\"Data\", [ Field(\"i\", CType(\"int\")), Field(\"f\", CType(\"float\")), ], is_union=True)  C++ class with method::  widget = Struct(\"Widget\", [ Field(\"width\", CType(\"int\")), ], methods=[ Function(\"resize\", CType(\"void\"), [ Parameter(\"w\", CType(\"int\")), Parameter(\"h\", CType(\"int\")), ]) ], is_cppclass=True)  Anonymous struct::  anon = Struct(None, [Field(\"value\", CType(\"int\"))])</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Struct:\n    \"\"\"Struct or union declaration.\n\n    Represents a C struct or union type definition. Both use the same\n    IR class with ``is_union`` distinguishing between them.\n\n    :param name: The struct/union tag name, or None for anonymous types.\n    :param fields: List of member fields.\n    :param methods: List of methods (for C++ classes only).\n    :param is_union: True for unions, False for structs.\n    :param is_cppclass: True for C++ classes (uses ``cppclass`` in Cython).\n    :param is_typedef: True if this came from a typedef declaration.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Simple struct::\n\n        point = Struct(\"Point\", [\n            Field(\"x\", CType(\"int\")),\n            Field(\"y\", CType(\"int\")),\n        ])\n\n    Union::\n\n        data = Struct(\"Data\", [\n            Field(\"i\", CType(\"int\")),\n            Field(\"f\", CType(\"float\")),\n        ], is_union=True)\n\n    C++ class with method::\n\n        widget = Struct(\"Widget\", [\n            Field(\"width\", CType(\"int\")),\n        ], methods=[\n            Function(\"resize\", CType(\"void\"), [\n                Parameter(\"w\", CType(\"int\")),\n                Parameter(\"h\", CType(\"int\")),\n            ])\n        ], is_cppclass=True)\n\n    Anonymous struct::\n\n        anon = Struct(None, [Field(\"value\", CType(\"int\"))])\n    \"\"\"\n\n    name: Optional[str]\n    fields: list[Field] = field(default_factory=list)\n    methods: list[Function] = field(default_factory=list)\n    is_union: bool = False\n    is_cppclass: bool = False\n    is_typedef: bool = False\n    namespace: Optional[str] = None\n    template_params: list[str] = field(default_factory=list)\n    cpp_name: Optional[str] = None\n    notes: list[str] = field(default_factory=list)\n    inner_typedefs: dict[str, str] = field(default_factory=dict)  # name -&gt; underlying_type\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        if self.is_cppclass:\n            kind = \"cppclass\"\n        elif self.is_union:\n            kind = \"union\"\n        else:\n            kind = \"struct\"\n        name_str = self.name or \"(anonymous)\"\n        return f\"{kind} {name_str}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Function","title":"<code>Function</code>  <code>dataclass</code>","text":"<p>Function declaration.</p> <p>Represents a C function prototype or declaration. Does not include the function body (declarations only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The function name.</p> required <code>return_type</code> <code>TypeExpr</code> <p>The function's return type.</p> required <code>parameters</code> <code>list[Parameter]</code> <p>List of function parameters.</p> <code>list()</code> <code>is_variadic</code> <code>bool</code> <p>True if the function accepts variable arguments.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Simple function::  exit_fn = Function(\"exit\", CType(\"void\"), [ Parameter(\"status\", CType(\"int\")) ])  With return value::  strlen_fn = Function(\"strlen\", CType(\"size_t\"), [ Parameter(\"s\", Pointer(CType(\"char\", [\"const\"]))) ])  Variadic function::  printf_fn = Function( \"printf\", CType(\"int\"), [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))], is_variadic=True )</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Function:\n    \"\"\"Function declaration.\n\n    Represents a C function prototype or declaration. Does not include\n    the function body (declarations only).\n\n    :param name: The function name.\n    :param return_type: The function's return type.\n    :param parameters: List of function parameters.\n    :param is_variadic: True if the function accepts variable arguments.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Simple function::\n\n        exit_fn = Function(\"exit\", CType(\"void\"), [\n            Parameter(\"status\", CType(\"int\"))\n        ])\n\n    With return value::\n\n        strlen_fn = Function(\"strlen\", CType(\"size_t\"), [\n            Parameter(\"s\", Pointer(CType(\"char\", [\"const\"])))\n        ])\n\n    Variadic function::\n\n        printf_fn = Function(\n            \"printf\",\n            CType(\"int\"),\n            [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))],\n            is_variadic=True\n        )\n    \"\"\"\n\n    name: str\n    return_type: TypeExpr\n    parameters: list[Parameter] = field(default_factory=list)\n    is_variadic: bool = False\n    namespace: Optional[str] = None\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        params = \", \".join(str(p) for p in self.parameters)\n        if self.is_variadic:\n            params = f\"{params}, ...\" if params else \"...\"\n        return f\"{self.return_type} {self.name}({params})\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Typedef","title":"<code>Typedef</code>  <code>dataclass</code>","text":"<p>Type alias declaration.</p> <p>Represents a C typedef that creates an alias for another type. Common patterns include aliasing primitives, struct tags, and function pointer types.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new type name being defined.</p> required <code>underlying_type</code> <code>TypeExpr</code> <p>The type being aliased.</p> required <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Simple alias::  size_t = Typedef(\"size_t\", CType(\"long\", [\"unsigned\"]))  Struct typedef::  point_t = Typedef(\"Point\", CType(\"struct Point\"))  Function pointer typedef::  callback_t = Typedef(\"Callback\", FunctionPointer( CType(\"void\"), [Parameter(\"data\", Pointer(CType(\"void\")))] ))</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Typedef:\n    \"\"\"Type alias declaration.\n\n    Represents a C typedef that creates an alias for another type.\n    Common patterns include aliasing primitives, struct tags, and\n    function pointer types.\n\n    :param name: The new type name being defined.\n    :param underlying_type: The type being aliased.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Simple alias::\n\n        size_t = Typedef(\"size_t\", CType(\"long\", [\"unsigned\"]))\n\n    Struct typedef::\n\n        point_t = Typedef(\"Point\", CType(\"struct Point\"))\n\n    Function pointer typedef::\n\n        callback_t = Typedef(\"Callback\", FunctionPointer(\n            CType(\"void\"),\n            [Parameter(\"data\", Pointer(CType(\"void\")))]\n        ))\n    \"\"\"\n\n    name: str\n    underlying_type: TypeExpr\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        return f\"typedef {self.underlying_type} {self.name}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Variable","title":"<code>Variable</code>  <code>dataclass</code>","text":"<p>Global variable declaration.</p> <p>Represents a global or extern variable declaration. Does not include local variables (which are not exposed in header files).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The variable name.</p> required <code>type</code> <code>TypeExpr</code> <p>The variable's type.</p> required <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Extern variable::  errno_var = Variable(\"errno\", CType(\"int\"))  Const string::  version = Variable(\"version\", Pointer(CType(\"char\", [\"const\"])))  Array variable::  lookup_table = Variable(\"table\", Array(CType(\"int\"), 256))</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Variable:\n    \"\"\"Global variable declaration.\n\n    Represents a global or extern variable declaration. Does not\n    include local variables (which are not exposed in header files).\n\n    :param name: The variable name.\n    :param type: The variable's type.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Extern variable::\n\n        errno_var = Variable(\"errno\", CType(\"int\"))\n\n    Const string::\n\n        version = Variable(\"version\", Pointer(CType(\"char\", [\"const\"])))\n\n    Array variable::\n\n        lookup_table = Variable(\"table\", Array(CType(\"int\"), 256))\n    \"\"\"\n\n    name: str\n    type: TypeExpr\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        return f\"{self.type} {self.name}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Constant","title":"<code>Constant</code>  <code>dataclass</code>","text":"<p>Compile-time constant declaration.</p> <p>Represents <code>#define</code> macros with constant values or <code>const</code> variable declarations. Only backends that support macro extraction (e.g., libclang) can populate macro constants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The constant name.</p> required <code>value</code> <code>Optional[Union[int, float, str]]</code> <p>The constant's value - an integer, float, or string expression. None if the value cannot be determined.</p> <code>None</code> <code>type</code> <code>Optional[CType]</code> <p>For typed constants (<code>const int</code>), the C type. None for macros.</p> <code>None</code> <code>is_macro</code> <code>bool</code> <p>True if this is a <code>#define</code> macro, False for <code>const</code> declarations.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Numeric macro::  size = Constant(\"SIZE\", 100, is_macro=True)  Expression macro::  mask = Constant(\"MASK\", \"1 &lt;&lt; 4\", is_macro=True)  Typed const::  max_val = Constant(\"MAX_VALUE\", 255, type=CType(\"int\"))  String macro::  version = Constant(\"VERSION\", '\"1.0.0\"', is_macro=True)</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Constant:\n    \"\"\"Compile-time constant declaration.\n\n    Represents ``#define`` macros with constant values or ``const``\n    variable declarations. Only backends that support macro extraction\n    (e.g., libclang) can populate macro constants.\n\n    :param name: The constant name.\n    :param value: The constant's value - an integer, float, or string\n        expression. None if the value cannot be determined.\n    :param type: For typed constants (``const int``), the C type.\n        None for macros.\n    :param is_macro: True if this is a ``#define`` macro, False for\n        ``const`` declarations.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Numeric macro::\n\n        size = Constant(\"SIZE\", 100, is_macro=True)\n\n    Expression macro::\n\n        mask = Constant(\"MASK\", \"1 &lt;&lt; 4\", is_macro=True)\n\n    Typed const::\n\n        max_val = Constant(\"MAX_VALUE\", 255, type=CType(\"int\"))\n\n    String macro::\n\n        version = Constant(\"VERSION\", '\"1.0.0\"', is_macro=True)\n    \"\"\"\n\n    name: str\n    value: Optional[Union[int, float, str]] = None  # None if complex/unknown\n    type: Optional[CType] = None\n    is_macro: bool = False\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        if self.is_macro:\n            return f\"#define {self.name} {self.value}\"\n        return f\"const {self.type} {self.name} = {self.value}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.SourceLocation","title":"<code>SourceLocation</code>  <code>dataclass</code>","text":"<p>Location in source file for error reporting and filtering.</p> <p>Used to track where declarations originated, enabling:</p> <ul> <li>Better error messages during parsing</li> <li>Filtering declarations by file (e.g., exclude system headers)</li> <li>Source mapping for debugging</li> </ul> <p>::</p> <pre><code>loc = SourceLocation(\"myheader.h\", 42, 5)\nprint(f\"Declaration at {loc.file}:{loc.line}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the source file.</p> required <code>line</code> <code>int</code> <p>Line number (1-indexed).</p> required <code>column</code> <code>Optional[int]</code> <p>Column number (1-indexed), or None if unknown.  Example -------</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass SourceLocation:\n    \"\"\"Location in source file for error reporting and filtering.\n\n    Used to track where declarations originated, enabling:\n\n    * Better error messages during parsing\n    * Filtering declarations by file (e.g., exclude system headers)\n    * Source mapping for debugging\n\n    :param file: Path to the source file.\n    :param line: Line number (1-indexed).\n    :param column: Column number (1-indexed), or None if unknown.\n\n    Example\n    -------\n    ::\n\n        loc = SourceLocation(\"myheader.h\", 42, 5)\n        print(f\"Declaration at {loc.file}:{loc.line}\")\n    \"\"\"\n\n    file: str\n    line: int\n    column: Optional[int] = None\n</code></pre>"},{"location":"api/ir/#autopxd.ir.ParserBackend","title":"<code>ParserBackend</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for parser backends.</p> <p>All parser backends must implement this protocol to be usable with autopxd2. Backends are responsible for translating from their native AST format (pycparser, libclang, etc.) to the common :class:<code>Header</code> IR format.</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend--available-backends","title":"Available Backends","text":"<ul> <li><code>pycparser</code> - Pure Python C99 parser (default)</li> <li><code>libclang</code> - LLVM clang-based parser with C++ support</li> </ul>"},{"location":"api/ir/#autopxd.ir.ParserBackend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends import get_backend\n\n# Get default backend\nbackend = get_backend()\n\n# Get specific backend\nlibclang = get_backend(\"libclang\")\n\n# Parse code\nheader = backend.parse(\"int foo(void);\", \"test.h\")\n</code></pre> Source code in <code>autopxd/ir.py</code> <pre><code>class ParserBackend(Protocol):  # pylint: disable=too-few-public-methods\n    \"\"\"Protocol defining the interface for parser backends.\n\n    All parser backends must implement this protocol to be usable with autopxd2.\n    Backends are responsible for translating from their native AST format\n    (pycparser, libclang, etc.) to the common :class:`Header` IR format.\n\n    Available Backends\n    ------------------\n    * ``pycparser`` - Pure Python C99 parser (default)\n    * ``libclang`` - LLVM clang-based parser with C++ support\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends import get_backend\n\n        # Get default backend\n        backend = get_backend()\n\n        # Get specific backend\n        libclang = get_backend(\"libclang\")\n\n        # Parse code\n        header = backend.parse(\"int foo(void);\", \"test.h\")\n    \"\"\"\n\n    # pylint: disable=unnecessary-ellipsis\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: Optional[list[str]] = None,\n        extra_args: Optional[list[str]] = None,\n    ) -&gt; Header:\n        \"\"\"Parse C/C++ code and return the IR representation.\n\n        :param code: Source code to parse.\n        :param filename: Name of the source file. Used for error messages\n            and ``#line`` directives. Does not need to exist on disk.\n        :param include_dirs: Directories to search for ``#include`` files.\n            Only used by backends that handle preprocessing.\n        :param extra_args: Additional arguments for the preprocessor/compiler.\n            Format is backend-specific.\n        :returns: Parsed header containing all extracted declarations.\n        :raises RuntimeError: If parsing fails due to syntax errors.\n        \"\"\"\n        ...\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Human-readable name of this backend (e.g., ``\"pycparser\"``).\"\"\"\n        ...\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        \"\"\"Whether this backend can extract ``#define`` constants.\"\"\"\n        ...\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        \"\"\"Whether this backend can parse C++ code.\"\"\"\n        ...\n</code></pre>"},{"location":"api/ir/#autopxd.ir.ParserBackend.name","title":"<code>name</code>  <code>property</code>","text":"<p>Human-readable name of this backend (e.g., <code>\"pycparser\"</code>).</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend.supports_macros","title":"<code>supports_macros</code>  <code>property</code>","text":"<p>Whether this backend can extract <code>#define</code> constants.</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend.supports_cpp","title":"<code>supports_cpp</code>  <code>property</code>","text":"<p>Whether this backend can parse C++ code.</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend.parse","title":"<code>parse(code, filename, include_dirs=None, extra_args=None)</code>","text":"<p>Parse C/C++ code and return the IR representation.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Source code to parse.</p> required <code>filename</code> <code>str</code> <p>Name of the source file. Used for error messages and <code>#line</code> directives. Does not need to exist on disk.</p> required <code>include_dirs</code> <code>Optional[list[str]]</code> <p>Directories to search for <code>#include</code> files. Only used by backends that handle preprocessing.</p> <code>None</code> <code>extra_args</code> <code>Optional[list[str]]</code> <p>Additional arguments for the preprocessor/compiler. Format is backend-specific.</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>Parsed header containing all extracted declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If parsing fails due to syntax errors.</p> Source code in <code>autopxd/ir.py</code> <pre><code>def parse(\n    self,\n    code: str,\n    filename: str,\n    include_dirs: Optional[list[str]] = None,\n    extra_args: Optional[list[str]] = None,\n) -&gt; Header:\n    \"\"\"Parse C/C++ code and return the IR representation.\n\n    :param code: Source code to parse.\n    :param filename: Name of the source file. Used for error messages\n        and ``#line`` directives. Does not need to exist on disk.\n    :param include_dirs: Directories to search for ``#include`` files.\n        Only used by backends that handle preprocessing.\n    :param extra_args: Additional arguments for the preprocessor/compiler.\n        Format is backend-specific.\n    :returns: Parsed header containing all extracted declarations.\n    :raises RuntimeError: If parsing fails due to syntax errors.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"getting-started/docker/","title":"Docker Usage","text":"<p>autopxd2 provides a Docker image with libclang pre-installed, allowing you to generate high-quality <code>.pxd</code> files without installing clang on your system.</p> <p>Recommended for C++ headers</p> <p>The Docker image is the easiest way to use the libclang backend, which provides better C++ support and handles complex headers that pycparser cannot parse.</p>"},{"location":"getting-started/docker/#quick-start","title":"Quick Start","text":"<p>Use the pre-built image from GitHub Container Registry:</p> <pre><code>docker pull ghcr.io/elijahr/python-autopxd2\n</code></pre> <p>Or build locally:</p> <pre><code>git clone https://github.com/elijahr/python-autopxd2.git\ncd python-autopxd2\ndocker build -t ghcr.io/elijahr/python-autopxd2 .\n</code></pre>"},{"location":"getting-started/docker/#usage-examples","title":"Usage Examples","text":""},{"location":"getting-started/docker/#generate-pxd-from-a-header-file","title":"Generate pxd from a header file","text":"<p>The container runs in <code>/work</code> by default, so mount your project there:</p> <pre><code># Mount current directory to /work and generate pxd\ndocker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 \\\n    autopxd myheader.h\n\n# Save output to a file\ndocker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 \\\n    autopxd myheader.h &gt; myheader.pxd\n</code></pre>"},{"location":"getting-started/docker/#c-headers","title":"C++ headers","text":"<pre><code># libclang is used by default in the container\ndocker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 \\\n    autopxd myheader.hpp\n</code></pre>"},{"location":"getting-started/docker/#include-directories","title":"Include directories","text":"<p>System include paths are automatically detected inside the container. For project-specific headers, mount the directories and use <code>-I</code>:</p> <pre><code># Project includes (already under /work)\ndocker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 \\\n    autopxd -I include -I src myheader.h\n</code></pre> <p>For external dependencies outside your project, mount them separately:</p> <pre><code># Mount external library to /third_party\ndocker run --rm \\\n    -v $(pwd):/work \\\n    -v ~/libs/somelib:/third_party \\\n    -w /work \\\n    ghcr.io/elijahr/python-autopxd2 \\\n    autopxd -I include -I /third_party/include myheader.h\n</code></pre> <p>Important: Any directory referenced with <code>-I</code> must be accessible inside the container. Use relative paths for directories under <code>/work</code>, or mount external directories and use absolute paths.</p>"},{"location":"getting-started/docker/#interactive-shell","title":"Interactive shell","text":"<pre><code># Get an interactive shell in the container\ndocker run --rm -it -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 bash\n\n# Then run autopxd commands interactively (paths are relative to /work)\nautopxd -I include myheader.h\n</code></pre>"},{"location":"getting-started/docker/#docker-compose","title":"Docker Compose","text":"<p>For projects that frequently use autopxd2, add it to your <code>docker-compose.yml</code>:</p> <pre><code>services:\n  autopxd:\n    image: ghcr.io/elijahr/python-autopxd2\n    volumes:\n      - .:/work\n    working_dir: /work\n</code></pre> <p>Then run:</p> <pre><code>docker compose run --rm autopxd autopxd myheader.h\n</code></pre>"},{"location":"getting-started/docker/#whats-included","title":"What's Included","text":"<p>The Docker image includes:</p> <ul> <li>Python 3.12</li> <li>clang and libclang development libraries</li> <li>autopxd2 with all dependencies</li> <li>The <code>clang</code> Python package for libclang bindings</li> </ul>"},{"location":"getting-started/docker/#building-for-different-architectures","title":"Building for Different Architectures","text":"<p>The Dockerfile supports both AMD64 and ARM64 architectures:</p> <pre><code># Build for current architecture\ndocker build -t autopxd2 .\n\n# Build for specific architecture\ndocker build --platform linux/amd64 -t autopxd2:amd64 .\ndocker build --platform linux/arm64 -t autopxd2:arm64 .\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#recommended-installation","title":"Recommended Installation","text":"<p>Install autopxd2 and the libclang backend for full C/C++ support:</p> <pre><code>pip install autopxd2\n</code></pre> <p>Then install the <code>clang2</code> package matching your system's LLVM version:</p> <pre><code># One-liner: detect LLVM version and install matching clang2\npip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre> <p>See libclang Setup below for platform-specific LLVM installation.</p> <p>Without clang2</p> <p>Without the <code>clang2</code> package, autopxd2 falls back to the legacy pycparser backend, which only supports C99 and lacks macro extraction, circular dependency handling, and C++ support. libclang is strongly recommended for all use cases.</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development, clone the repository and install with development dependencies:</p> <pre><code>git clone https://github.com/elijahr/python-autopxd2.git\ncd python-autopxd2\npip install -e .[dev]\n</code></pre>"},{"location":"getting-started/installation/#docker-no-installation-required","title":"Docker (No Installation Required)","text":"<p>Use the Docker image for libclang support without installing anything locally:</p> <pre><code>docker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 autopxd myheader.h\n</code></pre> <p>See Docker Usage for more details.</p>"},{"location":"getting-started/installation/#libclang-setup","title":"libclang Setup","text":"<p>The libclang backend (recommended for all use cases) requires:</p> <ol> <li>The system libclang library (LLVM)</li> <li>The Python <code>clang2</code> package matching your LLVM version</li> </ol> <p>Version Matching Required</p> <p>The <code>clang2</code> Python package must match your system's LLVM version. For example, LLVM 18 requires <code>clang2==18.*</code>.</p>"},{"location":"getting-started/installation/#quick-install-one-liner","title":"Quick Install (One-Liner)","text":"<p>If you have LLVM already installed, use this one-liner to install the matching clang2 package:</p> pipuv <pre><code>pip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre> <pre><code>uv pip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code># Install LLVM (if not already installed)\nbrew install llvm\n\n# Install matching clang2 package (one-liner)\npip install \"clang2==$($(brew --prefix llvm)/bin/llvm-config --version | cut -d. -f1).*\"\n</code></pre> <p>Or with uv:</p> <pre><code>uv pip install \"clang2==$($(brew --prefix llvm)/bin/llvm-config --version | cut -d. -f1).*\"\n</code></pre>"},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code># Install LLVM (if not already installed)\nsudo apt-get install libclang-dev llvm\n\n# Install matching clang2 package (one-liner)\npip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre> <p>Or with uv:</p> <pre><code>uv pip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre>"},{"location":"getting-started/installation/#fedorarhel","title":"Fedora/RHEL","text":"<pre><code># Install LLVM\nsudo dnf install clang-devel llvm\n\n# Install matching clang2 package\npip install \"clang2==$(llvm-config --version | cut -d. -f1).*\"\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Install LLVM from releases.llvm.org</li> <li>Add LLVM <code>bin</code> directory to your PATH</li> <li>Install matching clang2 package:</li> </ol> <pre><code># Check version first\nllvm-config --version\n\n# Install matching package (replace XX with major version)\npip install \"clang2==XX.*\"\n</code></pre>"},{"location":"getting-started/installation/#manual-version-check","title":"Manual Version Check","text":"<p>If the one-liner doesn't work, check your version manually:</p> <pre><code>llvm-config --version\n# Output: 18.1.3 (means you need clang2==18.*)\n\npip install \"clang2==18.*\"\n</code></pre>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Check that autopxd2 can find libclang:</p> <pre><code>autopxd --list-backends\n</code></pre> <p>If libclang is installed correctly, you should see:</p> <pre><code>Available backends:\n  libclang     Full C/C++ support via LLVM [available] (default)\n  pycparser    Legacy C99 parser [available]\n\nDefault: libclang\n</code></pre>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you try to use the libclang backend without clang2 installed, autopxd2 will detect your LLVM version and show the exact install command:</p> <pre><code>ValueError: libclang backend requires the clang2 package.\nDetected LLVM version 18 on your system.\nInstall with: pip install 'clang2==18.*'\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you generating Cython <code>.pxd</code> files in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<p>Given a C header file <code>example.h</code>:</p> <pre><code>// example.h\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nPoint create_point(int x, int y);\ndouble distance(Point a, Point b);\n</code></pre> <p>Generate a <code>.pxd</code> file:</p> <pre><code>autopxd example.h &gt; example.pxd\n</code></pre> <p>This produces:</p> <pre><code>cdef extern from \"example.h\":\n\n    cdef struct Point:\n        int x\n        int y\n\n    Point create_point(int x, int y)\n\n    double distance(Point a, Point b)\n</code></pre>"},{"location":"getting-started/quickstart/#include-directories","title":"Include Directories","text":"<p>The libclang backend automatically detects system include paths, so standard headers like <code>&lt;stddef.h&gt;</code> and <code>&lt;stdint.h&gt;</code> work out of the box.</p> <p>For project-specific includes, use <code>-I</code>:</p> <pre><code>autopxd -I ./include -I ./third_party myheader.h\n</code></pre> <p>To disable automatic system include detection (e.g., for cross-compilation), use <code>--no-default-includes</code>:</p> <pre><code>autopxd --no-default-includes -I /custom/sysroot/include myheader.h\n</code></pre>"},{"location":"getting-started/quickstart/#choosing-a-backend","title":"Choosing a Backend","text":"<p>autopxd2 supports two parser backends:</p> Backend Best For Requirements pycparser Simple C headers None (pure Python) libclang C++ headers, complex macros libclang installed <p>Use the <code>--backend</code> option:</p> <pre><code># Use pycparser (default)\nautopxd --backend pycparser myheader.h\n\n# Use libclang for C++ support\nautopxd --backend libclang myheader.hpp\n</code></pre>"},{"location":"getting-started/quickstart/#using-with-cython","title":"Using with Cython","text":"<p>After generating the <code>.pxd</code> file, use it in your Cython code:</p> <pre><code># mymodule.pyx\nfrom example cimport Point, create_point, distance\n\ndef make_point(x: int, y: int) -&gt; tuple:\n    cdef Point p = create_point(x, y)\n    return (p.x, p.y)\n\ndef calc_distance(p1: tuple, p2: tuple) -&gt; float:\n    cdef Point a, b\n    a.x, a.y = p1\n    b.x, b.y = p2\n    return distance(a, b)\n</code></pre>"},{"location":"getting-started/quickstart/#python-api","title":"Python API","text":"<p>You can also use autopxd2 programmatically:</p> <pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir_writer import write_pxd\n\n# Parse a header file\nbackend = get_backend(\"pycparser\")  # or \"libclang\"\nwith open(\"example.h\") as f:\n    code = f.read()\n\nheader = backend.parse(code, \"example.h\")\n\n# Generate pxd content\npxd = write_pxd(header)\nprint(pxd)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Parser Backends - Learn about backend differences</li> <li>C++ Support - Working with C++ headers</li> <li>Docker Usage - Use Docker for libclang without local installation</li> </ul>"},{"location":"user-guide/backends/","title":"Parser Backends","text":"<p>autopxd2 supports two parser backends. libclang is strongly recommended for all use cases.</p>"},{"location":"user-guide/backends/#available-backends","title":"Available Backends","text":""},{"location":"user-guide/backends/#libclang-recommended","title":"libclang (Recommended)","text":"<p>Uses LLVM's clang library for parsing. Provides the same parser used by production compilers.</p> <p>Pros:</p> <ul> <li>Full C++ support (classes, templates, namespaces)</li> <li>Extracts macros as constants (integers, floats, strings, expressions)</li> <li>Automatic system include path detection</li> <li>Handles comments and preprocessor directives directly</li> <li>Better error messages</li> <li>Handles complex headers reliably</li> </ul> <p>Cons:</p> <ul> <li>Requires libclang to be installed</li> <li>Python <code>clang2</code> package version must match system libclang (these are official LLVM bindings)</li> <li>Slightly slower startup time</li> <li>Function-like macros are not extracted</li> </ul> <p>Usage:</p> <pre><code>autopxd --backend libclang myheader.h\n\n# For C++ headers\nautopxd --backend libclang myheader.hpp\n</code></pre>"},{"location":"user-guide/backends/#system-include-paths","title":"System Include Paths","text":"<p>The libclang backend automatically detects system include directories by querying the system clang compiler. This means headers like <code>&lt;stddef.h&gt;</code> and <code>&lt;stdint.h&gt;</code> work without requiring manual <code>-I</code> flags.</p> <pre><code># This works automatically - system includes are detected\nautopxd myheader.h\n</code></pre> <p>To disable automatic include detection:</p> <pre><code>autopxd --no-default-includes myheader.h\n</code></pre> <p>You can still add additional include directories:</p> <pre><code>autopxd -I /my/project/include myheader.h\n</code></pre>"},{"location":"user-guide/backends/#pycparser-legacy","title":"pycparser (Legacy)","text":"<p>A pure Python C99 parser. Falls back to this if libclang is not available.</p> <p>Legacy Backend</p> <p>pycparser is maintained for backwards compatibility but is not recommended. It lacks C++ support, macro extraction, and circular dependency handling.</p> <p>Cons:</p> <ul> <li>C99 only (no C++ support)</li> <li>No macro extraction</li> <li>No circular dependency handling</li> <li>Requires preprocessed code</li> <li>May struggle with complex headers</li> </ul> <p>Usage:</p> <pre><code>autopxd --backend pycparser myheader.h\n</code></pre>"},{"location":"user-guide/backends/#choosing-a-backend","title":"Choosing a Backend","text":"<p>Use libclang for everything. The only reason to use pycparser is if you cannot install LLVM on your system.</p> Use Case Recommended Backend C headers libclang C++ headers libclang Headers with macros libclang Complex library headers libclang Cannot install LLVM pycparser (fallback)"},{"location":"user-guide/backends/#backend-comparison","title":"Backend Comparison","text":"<p>Both backends produce equivalent output for standard C constructs:</p> <pre><code>// input.h\nstruct Point {\n    int x;\n    int y;\n};\n\nint distance(struct Point a, struct Point b);\n</code></pre> <p>Both backends produce:</p> <pre><code>cdef extern from \"input.h\":\n\n    cdef struct Point:\n        int x\n        int y\n\n    int distance(Point a, Point b)\n</code></pre>"},{"location":"user-guide/backends/#macro-extraction-libclang-only","title":"Macro Extraction (libclang only)","text":"<p>The libclang backend extracts <code>#define</code> macros as Cython constant declarations. The type is automatically detected from the macro value.</p>"},{"location":"user-guide/backends/#integer-macros","title":"Integer Macros","text":"<pre><code>#define SIZE 100\n#define MASK 0xFF\n#define MODE 0755\n#define FLAGS 0b1010\n#define BIG_NUM 100ULL\n</code></pre> <p>Generates <code>int</code> declarations:</p> <pre><code>    int SIZE\n    int MASK\n    int MODE\n    int FLAGS\n    int BIG_NUM\n</code></pre> <p>Supported formats: decimal, hex (<code>0x</code>), octal (<code>0</code>), binary (<code>0b</code>), with optional type suffixes (<code>U</code>, <code>L</code>, <code>UL</code>, <code>LL</code>, <code>ULL</code>).</p>"},{"location":"user-guide/backends/#floating-point-macros","title":"Floating-Point Macros","text":"<pre><code>#define PI 3.14159\n#define EPSILON 1e-10\n#define FACTOR 2.5f\n</code></pre> <p>Generates <code>double</code> declarations:</p> <pre><code>    double PI\n    double EPSILON\n    double FACTOR\n</code></pre>"},{"location":"user-guide/backends/#string-macros","title":"String Macros","text":"<pre><code>#define VERSION \"1.0.0\"\n#define APP_NAME \"myapp\"\n</code></pre> <p>Generates <code>const char*</code> declarations:</p> <pre><code>    const char* VERSION\n    const char* APP_NAME\n</code></pre>"},{"location":"user-guide/backends/#expression-macros","title":"Expression Macros","text":"<pre><code>#define A 10\n#define B 20\n#define TOTAL (A + B)\n#define FLAGS (0x01 | 0x02)\n#define NEGATIVE -1\n</code></pre> <p>Expression macros that consist of numeric literals, operators, and other macro references are detected and declared with appropriate types:</p> <pre><code>    int A\n    int B\n    int TOTAL\n    int FLAGS\n    int NEGATIVE\n</code></pre>"},{"location":"user-guide/backends/#unsupported-macros-silently-ignored","title":"Unsupported Macros (silently ignored)","text":"<ul> <li>Function-like macros: <code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</code></li> <li>Empty macros: <code>#define EMPTY</code></li> <li>String concatenation: <code>#define CONCAT \"hello\" \"world\"</code></li> </ul> <p>The pycparser backend does not extract macros since it requires preprocessed input.</p>"},{"location":"user-guide/backends/#c-template-support-libclang-only","title":"C++ Template Support (libclang only)","text":"<p>The libclang backend supports C++ templates, including primary templates and full specializations.</p>"},{"location":"user-guide/backends/#primary-templates","title":"Primary Templates","text":"<p>C++ class templates with type parameters are translated to Cython's template syntax:</p> <pre><code>template&lt;typename T&gt;\nclass Container {\npublic:\n    T value;\n    T get();\n    void set(T v);\n};\n</code></pre> <p>Generates:</p> <pre><code>cdef cppclass Container[T]:\n    T value\n    T get()\n    void set(T v)\n</code></pre> <p>Multiple type parameters are supported:</p> <pre><code>template&lt;typename K, typename V&gt;\nclass Map {\npublic:\n    V lookup(K key);\n    void insert(K key, V value);\n};\n</code></pre> <p>Generates:</p> <pre><code>cdef cppclass Map[K, V]:\n    V lookup(K key)\n    void insert(K key, V value)\n</code></pre>"},{"location":"user-guide/backends/#template-specializations","title":"Template Specializations","text":"<p>Full template specializations are emitted with mangled Python-safe names and the original C++ name as a string literal:</p> <pre><code>template&lt;&gt;\nclass Container&lt;int&gt; {\npublic:\n    int special_value;\n    int get_special();\n};\n</code></pre> <p>Generates:</p> <pre><code>cdef cppclass Container_int \"Container&lt;int&gt;\":\n    int special_value\n    int get_special()\n</code></pre> <p>The mangling scheme converts special characters to valid Python identifiers: - <code>&lt;</code> and <code>&gt;</code> are removed, contents become underscore-separated - <code>*</code> becomes <code>_ptr</code> - <code>&amp;</code> becomes <code>_ref</code> - <code>::</code> becomes <code>_</code></p> <p>Examples: - <code>Container&lt;int&gt;</code> \u2192 <code>Container_int</code> - <code>Map&lt;int, double&gt;</code> \u2192 <code>Map_int_double</code> - <code>Foo&lt;int*&gt;</code> \u2192 <code>Foo_int_ptr</code></p>"},{"location":"user-guide/backends/#using-docker-for-libclang","title":"Using Docker for libclang","text":"<p>If you don't want to install libclang locally, use the Docker image:</p> <pre><code>docker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 autopxd myheader.h\n</code></pre> <p>See Docker Usage for details.</p>"},{"location":"user-guide/backends/#programmatic-backend-selection","title":"Programmatic Backend Selection","text":"<pre><code>from autopxd.backends import get_backend, list_backends\n\n# List available backends\nprint(list_backends())  # ['pycparser', 'libclang'] (if libclang installed)\n\n# Get a specific backend\nbackend = get_backend(\"libclang\")\n\n# Parse a header\nheader = backend.parse(code, \"myheader.h\")\n</code></pre>"},{"location":"user-guide/cli/","title":"CLI Reference","text":"<p>The <code>autopxd</code> command-line tool generates Cython <code>.pxd</code> files from C/C++ headers.</p>"},{"location":"user-guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>autopxd [OPTIONS] [INFILE] [OUTFILE]\n</code></pre>"},{"location":"user-guide/cli/#options","title":"Options","text":""},{"location":"user-guide/cli/#-v-version","title":"<code>-v, --version</code>","text":"<p>Print program version and exit.</p> <pre><code>autopxd --version\n</code></pre>"},{"location":"user-guide/cli/#-b-backend-name","title":"<code>-b, --backend &lt;name&gt;</code>","text":"<p>Select the parser backend. Options: <code>auto</code> (default), <code>libclang</code>, <code>pycparser</code>.</p> <ul> <li><code>auto</code>: Use libclang if available, fall back to pycparser</li> <li><code>libclang</code>: Full C/C++ support via LLVM</li> <li><code>pycparser</code>: Legacy C99 parser (no C++ support)</li> </ul> <pre><code>autopxd --backend libclang myheader.hpp\nautopxd -b pycparser myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-list-backends","title":"<code>--list-backends</code>","text":"<p>Show available backends and exit.</p> <pre><code>autopxd --list-backends\n</code></pre>"},{"location":"user-guide/cli/#-json","title":"<code>--json</code>","text":"<p>Output in JSON format (for use with <code>--list-backends</code>).</p> <pre><code>autopxd --list-backends --json\n</code></pre>"},{"location":"user-guide/cli/#-x-cpp","title":"<code>-x, --cpp</code>","text":"<p>Parse as C++ (requires libclang backend).</p> <pre><code>autopxd --cpp myclass.hpp\n</code></pre>"},{"location":"user-guide/cli/#-std-standard","title":"<code>--std &lt;standard&gt;</code>","text":"<p>Specify the language standard (requires libclang backend).</p> <pre><code>autopxd --std c11 myheader.h\nautopxd --std c++17 myclass.hpp\n</code></pre>"},{"location":"user-guide/cli/#-i-include-dir-dir","title":"<code>-I, --include-dir &lt;dir&gt;</code>","text":"<p>Add a directory to the include search path. Can be specified multiple times.</p> <p>Note: The libclang backend automatically detects system include paths (e.g., <code>/usr/include</code>), so you typically only need <code>-I</code> for project-specific directories.</p> <pre><code>autopxd -I ./include -I ./third_party myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-d-define-macro","title":"<code>-D, --define &lt;macro&gt;</code>","text":"<p>Define a preprocessor macro. Can be specified multiple times.</p> <pre><code>autopxd -D DEBUG -D VERSION=2 myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-w-whitelist-file","title":"<code>-w, --whitelist &lt;file&gt;</code>","text":"<p>Only generate declarations from specified files. Can be specified multiple times.</p> <pre><code>autopxd -w main.h -w types.h combined.h\n</code></pre>"},{"location":"user-guide/cli/#-clang-arg-arg-libclang","title":"<code>--clang-arg &lt;arg&gt;</code> [libclang]","text":"<p>Pass an argument directly to libclang. Can be specified multiple times.</p> <pre><code>autopxd --clang-arg -DFOO --clang-arg -I/custom/include myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-no-default-includes-libclang","title":"<code>--no-default-includes</code> [libclang]","text":"<p>Disable automatic detection of system include directories. By default, the libclang backend queries the system clang compiler to find standard include paths. Use this option if you need full control over include paths.</p> <pre><code># Disable auto-detection and specify all paths manually\nautopxd --no-default-includes -I /my/custom/sysroot/include myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-p-project-prefix-path-libclang","title":"<code>-P, --project-prefix &lt;path&gt;</code> [libclang]","text":"<p>Treat headers under the specified path as project headers rather than system headers. This is essential for umbrella headers\u2014headers that include many sub-headers but have few declarations of their own (like <code>sodium.h</code>, <code>openssl/ssl.h</code>).</p> <p>Without this option, declarations from sub-headers in system locations (e.g., <code>/usr/include</code>, <code>/opt/homebrew/include</code>) are filtered out. The <code>--project-prefix</code> option whitelists paths so their declarations are included.</p> <p>Can be specified multiple times for multiple prefixes.</p> <pre><code># Include declarations from all sodium/*.h sub-headers\nautopxd -I /opt/homebrew/include \\\n    --project-prefix /opt/homebrew/include/sodium \\\n    /opt/homebrew/include/sodium.h\n\n# Multiple prefixes\nautopxd -I /usr/include \\\n    -P /usr/include/openssl \\\n    -P /usr/include/crypto \\\n    /usr/include/openssl/ssl.h\n</code></pre>"},{"location":"user-guide/cli/#-no-recursive-libclang","title":"<code>--no-recursive</code> [libclang]","text":"<p>Disable recursive parsing of umbrella headers. By default, when an umbrella header is detected, autopxd recursively parses included project headers to collect all declarations. Use this option to only parse the top-level header.</p> <pre><code>autopxd --no-recursive -P /opt/homebrew/include/sodium \\\n    /opt/homebrew/include/sodium.h\n</code></pre>"},{"location":"user-guide/cli/#-max-depth-n-libclang","title":"<code>--max-depth &lt;n&gt;</code> [libclang]","text":"<p>Set the maximum recursion depth for umbrella header processing (default: 10). This prevents infinite recursion in cases of circular includes.</p> <pre><code>autopxd --max-depth 5 -P /opt/homebrew/include/sodium \\\n    /opt/homebrew/include/sodium.h\n</code></pre>"},{"location":"user-guide/cli/#-q-quiet","title":"<code>-q, --quiet</code>","text":"<p>Suppress warnings (e.g., backend fallback warnings).</p> <pre><code>autopxd -q myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-debug-no-debug","title":"<code>--debug / --no-debug</code>","text":"<p>Dump preprocessor output to stderr for debugging.</p> <pre><code>autopxd --debug myheader.h 2&gt;preprocessed.txt\n</code></pre>"},{"location":"user-guide/cli/#-h-help","title":"<code>-h, --help</code>","text":"<p>Show help message and exit.</p> <pre><code>autopxd --help\n</code></pre>"},{"location":"user-guide/cli/#examples","title":"Examples","text":""},{"location":"user-guide/cli/#generate-pxd-from-a-header","title":"Generate pxd from a header","text":"<pre><code>autopxd myheader.h myheader.pxd\n</code></pre>"},{"location":"user-guide/cli/#with-include-directories","title":"With include directories","text":"<pre><code>autopxd -I /opt/local/include -I ./third_party mylib.h mylib.pxd\n</code></pre>"},{"location":"user-guide/cli/#using-libclang-for-c","title":"Using libclang for C++","text":"<pre><code>autopxd --backend libclang --cpp myclass.hpp myclass.pxd\n</code></pre>"},{"location":"user-guide/cli/#using-c17-standard","title":"Using C++17 standard","text":"<pre><code>autopxd -x --std c++17 modern.hpp modern.pxd\n</code></pre>"},{"location":"user-guide/cli/#working-with-umbrella-headers","title":"Working with umbrella headers","text":"<p>Umbrella headers like <code>sodium.h</code> include many sub-headers but define few declarations themselves. Use <code>--project-prefix</code> to include declarations from sub-headers:</p> <pre><code># Generate bindings for libsodium (installed via homebrew)\nautopxd -I /opt/homebrew/include \\\n    -P /opt/homebrew/include/sodium \\\n    /opt/homebrew/include/sodium.h sodium.pxd\n\n# Generate bindings for OpenSSL\nautopxd -I /usr/include \\\n    -P /usr/include/openssl \\\n    /usr/include/openssl/ssl.h ssl.pxd\n</code></pre>"},{"location":"user-guide/cli/#check-available-backends","title":"Check available backends","text":"<pre><code>autopxd --list-backends\n</code></pre>"},{"location":"user-guide/cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/cli/#libclang-not-available","title":"libclang not available","text":"<p>If you see \"libclang not available, falling back to pycparser\", install the system libclang library:</p> <p>Ubuntu/Debian: <pre><code>apt install libclang-dev\n</code></pre></p> <p>macOS: <pre><code>brew install llvm\n</code></pre></p> <p>Or use Docker: <pre><code>docker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 autopxd myheader.h\n</code></pre></p>"},{"location":"user-guide/cli/#c-parsing-fails","title":"C++ parsing fails","text":"<p>Make sure you're using the libclang backend:</p> <pre><code>autopxd --backend libclang --cpp myheader.hpp\n</code></pre>"},{"location":"user-guide/cli/#empty-output-from-umbrella-headers","title":"Empty output from umbrella headers","text":"<p>If you're parsing an umbrella header (like <code>sodium.h</code>) and getting empty or minimal output, the sub-headers are probably in a system location. Use <code>--project-prefix</code> to whitelist them:</p> <pre><code># Find where the library headers are installed\npkg-config --cflags libsodium\n# Output: -I/opt/homebrew/include\n\n# Use --project-prefix with the sub-header directory\nautopxd -I /opt/homebrew/include \\\n    -P /opt/homebrew/include/sodium \\\n    /opt/homebrew/include/sodium.h\n</code></pre> <p>You can verify the prefix is working by using <code>--debug</code> to see which declarations are being found.</p>"},{"location":"user-guide/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Parse error or invalid input 2 Invalid command-line arguments"},{"location":"user-guide/cpp/","title":"C++ Support","text":"<p>autopxd2 supports C++ headers through the libclang backend.</p> <p>Important</p> <p>C++ support requires the libclang backend. The default pycparser backend only supports C99.</p>"},{"location":"user-guide/cpp/#basic-c-usage","title":"Basic C++ Usage","text":"<pre><code># Use libclang for C++ headers\nautopxd --backend libclang myclass.hpp &gt; myclass.pxd\n</code></pre> <p>Or with Docker:</p> <pre><code>docker run --rm -v $(pwd):/work -w /work ghcr.io/elijahr/python-autopxd2 autopxd myclass.hpp\n</code></pre>"},{"location":"user-guide/cpp/#supported-c-features","title":"Supported C++ Features","text":""},{"location":"user-guide/cpp/#classes","title":"Classes","text":"<p>C++ classes are converted to Cython structs:</p> <pre><code>// widget.hpp\nclass Widget {\npublic:\n    int width;\n    int height;\n};\n</code></pre> <p>Generates:</p> <pre><code>cdef extern from \"widget.hpp\":\n\n    cdef struct Widget:\n        int width\n        int height\n</code></pre>"},{"location":"user-guide/cpp/#structs","title":"Structs","text":"<p>C++ structs work the same as C:</p> <pre><code>struct Point {\n    double x;\n    double y;\n};\n</code></pre>"},{"location":"user-guide/cpp/#functions","title":"Functions","text":"<p>Global functions are converted directly:</p> <pre><code>double distance(const Point&amp; a, const Point&amp; b);\n</code></pre> <p>Generates:</p> <pre><code>double distance(const Point &amp; a, const Point &amp; b)\n</code></pre>"},{"location":"user-guide/cpp/#namespaces","title":"Namespaces","text":"<p>Currently, only top-level declarations are extracted. Namespaced declarations are not directly supported.</p>"},{"location":"user-guide/cpp/#limitations","title":"Limitations","text":""},{"location":"user-guide/cpp/#methods","title":"Methods","text":"<p>Class methods are not included in the generated <code>.pxd</code>. Only public data members are extracted.</p> <p>For full method support, you'll need to manually add method declarations or use Cython's <code>cppclass</code> syntax.</p>"},{"location":"user-guide/cpp/#templates","title":"Templates","text":"<p>Template classes are supported through the libclang backend, including primary templates and full specializations. See C++ Template Support for details.</p>"},{"location":"user-guide/cpp/#overloading","title":"Overloading","text":"<p>Multiple overloaded functions with the same name may produce conflicts. You may need to manually select which overload to use.</p>"},{"location":"user-guide/cpp/#best-practices","title":"Best Practices","text":"<ol> <li>Use header-only libraries where possible for simpler integration</li> <li>Start with the Docker image to avoid libclang installation issues</li> <li>Check generated output and manually adjust for complex C++ features</li> <li>Consider Cython's cppclass for classes with methods you need to call</li> </ol>"},{"location":"user-guide/cpp/#example-workflow","title":"Example Workflow","text":"<ol> <li> <p>Generate initial pxd:    <pre><code>autopxd --backend libclang mylib.hpp &gt; mylib.pxd\n</code></pre></p> </li> <li> <p>Review and adjust for methods, templates, or other features</p> </li> <li> <p>Create your Cython wrapper:    <pre><code># mylib.pyx\nfrom mylib cimport Widget\n\ndef create_widget(width: int, height: int):\n    cdef Widget w\n    w.width = width\n    w.height = height\n    return (w.width, w.height)\n</code></pre></p> </li> </ol>"}]}