{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"autopxd2","text":"<p>Automatically generate Cython pxd files from C/C++ headers.</p> <p>autopxd2 parses C header files and generates Cython <code>.pxd</code> declaration files, enabling you to call C code from Python with minimal manual effort.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Automatic pxd generation - Convert C headers to Cython declarations</li> <li>Multiple parser backends - pycparser (pure Python) and libclang (C++ support)</li> <li>Docker support - Generate headers without installing clang locally</li> <li>CLI and Python API - Use from command line or integrate into your build</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code># Generate pxd from a C header\nautopxd myheader.h &gt; myheader.pxd\n\n# Use libclang backend for C++ support (requires clang)\nautopxd --backend libclang myheader.hpp &gt; myheader.pxd\n\n# Or use Docker for libclang without local installation\ndocker run --rm -v $(pwd):/work autopxd2 autopxd /work/myheader.h\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install autopxd2\n</code></pre> <p>The libclang backend is used automatically if your system has libclang installed. See Installation Guide for setting up libclang.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Detailed installation options</li> <li>Quick Start - Get started in 5 minutes</li> <li>Docker Usage - Use Docker for libclang support</li> <li>Parser Backends - Choose the right backend</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>We welcome contributions to autopxd2!</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>We recommend using uv for fast dependency management.</p> <ol> <li> <p>Clone the repository:    <pre><code>git clone https://github.com/elijahr/python-autopxd2.git\ncd python-autopxd2\n</code></pre></p> </li> <li> <p>Create a virtual environment and install dependencies:    <pre><code># Using uv (recommended)\nuv venv\nsource .venv/bin/activate  # or `.venv\\Scripts\\activate` on Windows\nuv pip install -e '.[test,lint,docs]'\n\n# Or using pip\npython -m venv .venv\nsource .venv/bin/activate\npip install -e '.[test,lint,docs]'\n</code></pre></p> </li> <li> <p>Install pre-commit hooks:    <pre><code>pre-commit install\n</code></pre></p> </li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with verbose output\npytest -v\n\n# Run specific test file\npytest test/test_ir.py\n\n# Run tests with coverage\npytest --cov=autopxd\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>We use ruff for linting and formatting:</p> <pre><code># Check for issues\nruff check autopxd\n\n# Auto-fix issues\nruff check --fix autopxd\n\n# Format code\nruff format autopxd\n</code></pre> <p>Pre-commit hooks run automatically on commit to ensure consistent style.</p>"},{"location":"contributing/#type-checking","title":"Type Checking","text":"<p>We use mypy with strict mode:</p> <pre><code>mypy autopxd/ --strict\n</code></pre>"},{"location":"contributing/#building-documentation","title":"Building Documentation","text":"<pre><code># Serve docs locally with live reload\nuv run mkdocs serve\n\n# Or without uv\nmkdocs serve\n\n# Build static site\nmkdocs build\n</code></pre> <p>The docs will be available at <code>http://127.0.0.1:8000/</code>.</p>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch: <code>git checkout -b feature/my-feature</code></li> <li>Make your changes</li> <li>Run tests: <code>pytest</code></li> <li>Run linters: <code>ruff check autopxd</code></li> <li>Run type check: <code>mypy autopxd/ --strict</code></li> <li>Commit with a clear message</li> <li>Push and create a pull request</li> </ol>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Please report issues on GitHub Issues.</p> <p>Include:</p> <ul> <li>Python version</li> <li>Operating system</li> <li>Steps to reproduce</li> <li>Expected vs actual behavior</li> <li>Relevant error messages or output</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>This section documents the public Python API for autopxd2.</p>"},{"location":"api/#modules","title":"Modules","text":""},{"location":"api/#ir-module","title":"IR Module","text":"<p>The Intermediate Representation (IR) module defines data structures for representing C/C++ constructs:</p> <ul> <li><code>Header</code> - Top-level container for parsed declarations</li> <li><code>Struct</code>, <code>Enum</code>, <code>Function</code>, <code>Typedef</code>, <code>Variable</code> - Declaration types</li> <li><code>CType</code>, <code>Pointer</code>, <code>Array</code>, <code>FunctionPointer</code> - Type representations</li> </ul>"},{"location":"api/#backends","title":"Backends","text":"<p>Parser backend implementations:</p> <ul> <li><code>PycparserBackend</code> - Pure Python C99 parser</li> <li><code>LibclangBackend</code> - LLVM clang-based parser with C++ support</li> </ul>"},{"location":"api/#quick-example","title":"Quick Example","text":"<pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir_writer import write_pxd\n\n# Parse a header\nbackend = get_backend()  # Uses default (pycparser)\nwith open(\"myheader.h\") as f:\n    code = f.read()\n\nheader = backend.parse(code, \"myheader.h\")\n\n# Generate pxd output\npxd = write_pxd(header)\nprint(pxd)\n</code></pre>"},{"location":"api/#common-patterns","title":"Common Patterns","text":""},{"location":"api/#inspecting-parsed-declarations","title":"Inspecting Parsed Declarations","text":"<pre><code>from autopxd.ir import Struct, Function\n\nheader = backend.parse(code, \"header.h\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Struct):\n        print(f\"Struct: {decl.name}\")\n        for field in decl.fields:\n            print(f\"  {field.name}: {field.type}\")\n    elif isinstance(decl, Function):\n        print(f\"Function: {decl.name}\")\n        print(f\"  Returns: {decl.return_type}\")\n</code></pre>"},{"location":"api/#choosing-a-backend","title":"Choosing a Backend","text":"<pre><code>from autopxd.backends import get_backend, list_backends\n\n# List available backends\nprint(list_backends())  # ['pycparser', 'libclang']\n\n# Get a specific backend\nbackend = get_backend(\"libclang\")\n</code></pre>"},{"location":"api/backends/","title":"Backends","text":"<p>Parser backends convert C/C++ source code into the autopxd IR.</p>"},{"location":"api/backends/#backend-registry","title":"Backend Registry","text":""},{"location":"api/backends/#autopxd.backends","title":"<code>backends</code>","text":"<p>Parser backends for autopxd.</p> <p>This package contains parser backend implementations that convert C/C++ source code into the autopxd IR (Intermediate Representation).</p>"},{"location":"api/backends/#autopxd.backends--available-backends","title":"Available Backends","text":"<p>pycparser     Pure Python C99 parser. Default backend with no external dependencies.     Requires preprocessed input (CPP/clang -E output).</p> <p>libclang     LLVM clang-based parser with full C++ support. Requires system     libclang library and matching <code>clang2</code> Python package.</p>"},{"location":"api/backends/#autopxd.backends--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends import get_backend, list_backends\n\n# Get the default backend\nbackend = get_backend()\n\n# Get a specific backend\nbackend = get_backend(\"libclang\")\n\n# List available backends\nfor name in list_backends():\n    print(name)\n</code></pre>"},{"location":"api/backends/#autopxd.backends.get_backend","title":"<code>get_backend(name=None)</code>","text":"<p>Get a parser backend instance.</p> <p>Returns a new instance of the requested backend. If no name is provided, returns the default backend (pycparser).</p> <p>::</p> <pre><code>from autopxd.backends import get_backend\n\n# Get default backend\nbackend = get_backend()\n\n# Get libclang backend\nclang = get_backend(\"libclang\")\n\n# Parse a header\nheader = backend.parse(code, \"myheader.h\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>Backend name (e.g., <code>\"pycparser\"</code>, <code>\"libclang\"</code>), or None for the default backend.</p> <code>None</code> <p>Returns:</p> Type Description <code>ParserBackend</code> <p>New instance of the requested backend.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the requested backend is not available.  Example -------</p>"},{"location":"api/backends/#autopxd.backends.list_backends","title":"<code>list_backends()</code>","text":"<p>List names of all registered backends.</p> <p>::</p> <pre><code>from autopxd.backends import list_backends\n\nfor name in list_backends():\n    print(f\"Available: {name}\")\n</code></pre> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of backend names that can be passed to :func:<code>get_backend</code>.  Example -------</p>"},{"location":"api/backends/#autopxd.backends.register_backend","title":"<code>register_backend(name, backend_class, is_default=False)</code>","text":"<p>Register a parser backend.</p> <p>Called by backend modules during import to add themselves to the registry. The first registered backend becomes the default unless <code>is_default</code> is explicitly set on a later registration.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique name for the backend (e.g., <code>\"pycparser\"</code>, <code>\"libclang\"</code>).</p> required <code>backend_class</code> <code>type[ParserBackend]</code> <p>Class implementing the :class:<code>~autopxd.ir.ParserBackend</code> protocol.</p> required <code>is_default</code> <code>bool</code> <p>If True, this becomes the default backend for :func:<code>get_backend</code>.</p> <code>False</code>"},{"location":"api/backends/#pycparser-backend","title":"pycparser Backend","text":""},{"location":"api/backends/#autopxd.backends.pycparser_backend","title":"<code>pycparser_backend</code>","text":"<p>pycparser-based parser backend.</p> <p>This backend uses pycparser (pure Python C99 parser) to parse C header files. It's the default backend since it requires no external dependencies beyond the pycparser package itself.</p>"},{"location":"api/backends/#autopxd.backends.pycparser_backend--limitations","title":"Limitations","text":"<ul> <li>C99 only - no C++ support (use libclang for C++)</li> <li>Cannot extract <code>#define</code> macro values (processed by preprocessor)</li> </ul>"},{"location":"api/backends/#autopxd.backends.pycparser_backend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.pycparser_backend import PycparserBackend\n\nbackend = PycparserBackend()\nheader = backend.parse(code, \"myheader.h\")\n</code></pre>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend","title":"<code>PycparserBackend</code>","text":"<p>Parser backend using pycparser.</p> <p>The default autopxd parser backend, using the pure-Python pycparser library. This backend has no external dependencies but requires preprocessed C code as input.</p>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend--properties","title":"Properties","text":"<p>name : str     Returns <code>\"pycparser\"</code>. supports_macros : bool     Returns <code>False</code> - macros are consumed by the preprocessor. supports_cpp : bool     Returns <code>False</code> - pycparser only supports C99.</p>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.pycparser_backend import PycparserBackend\n\nbackend = PycparserBackend()\n\n# Parse preprocessed code\npreprocessed = run_cpp(\"myheader.h\")\nheader = backend.parse(preprocessed, \"myheader.h\")\n\nfor decl in header.declarations:\n    print(decl)\n</code></pre> Source code in <code>autopxd/backends/pycparser_backend.py</code> <pre><code>class PycparserBackend:\n    \"\"\"Parser backend using pycparser.\n\n    The default autopxd parser backend, using the pure-Python pycparser\n    library. This backend has no external dependencies but requires\n    preprocessed C code as input.\n\n    Properties\n    ----------\n    name : str\n        Returns ``\"pycparser\"``.\n    supports_macros : bool\n        Returns ``False`` - macros are consumed by the preprocessor.\n    supports_cpp : bool\n        Returns ``False`` - pycparser only supports C99.\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends.pycparser_backend import PycparserBackend\n\n        backend = PycparserBackend()\n\n        # Parse preprocessed code\n        preprocessed = run_cpp(\"myheader.h\")\n        header = backend.parse(preprocessed, \"myheader.h\")\n\n        for decl in header.declarations:\n            print(decl)\n    \"\"\"\n\n    @property\n    def name(self) -&gt; str:\n        return \"pycparser\"\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        return False\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        return False\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n    ) -&gt; Header:\n        \"\"\"Parse C code using pycparser.\n\n        The code is automatically preprocessed using the system's C preprocessor\n        (``cpp`` on Unix/Mac, ``clang -E`` on macOS, or ``cl.exe /E`` on Windows).\n\n        :param code: C source code to parse.\n        :param filename: Source filename for error messages and location tracking.\n        :param include_dirs: Additional include directories for the preprocessor.\n        :param extra_args: Extra arguments to pass to the preprocessor.\n        :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n        :raises RuntimeError: If preprocessing fails.\n        :raises pycparser.plyparser.ParseError: If the code has syntax errors.\n        \"\"\"\n        # pylint: disable=import-outside-toplevel\n        from pycparser import (\n            c_parser,\n        )\n\n        # Preprocess the code\n        preprocessed = self._preprocess(code, include_dirs, extra_args)\n\n        parser = c_parser.CParser()\n        ast = parser.parse(preprocessed, filename=filename)\n\n        converter = ASTConverter(filename)\n        return converter.convert(ast)\n\n    def _preprocess(\n        self,\n        code: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n    ) -&gt; str:\n        \"\"\"Preprocess C code using the system's C preprocessor.\n\n        :param code: C source code to preprocess.\n        :param include_dirs: Additional include directories.\n        :param extra_args: Extra preprocessor arguments (e.g., -DFOO=1).\n        :returns: Preprocessed code.\n        :raises RuntimeError: If preprocessing fails.\n        \"\"\"\n        if include_dirs is None:\n            include_dirs = []\n        if extra_args is None:\n            extra_args = []\n\n        # Build include paths\n        includes: list[str] = []\n        if platform.system() == \"Darwin\":\n            cmd = [\"clang\", \"-E\"]\n            includes.append(str(DARWIN_HEADERS_DIR))\n        else:\n            cmd = [\"cpp\"]\n        includes.append(str(BUILTIN_HEADERS_DIR))\n\n        # Build command\n        cmd += [f\"-I{inc}\" for inc in includes]\n        cmd += [\"-nostdinc\", \"-iquote\"]\n        cmd += [f\"-I{inc}\" for inc in includes]\n        cmd += [\n            \"-D__attribute__(x)=\",\n            \"-D__extension__=\",\n            \"-D__inline=\",\n            \"-D__asm=\",\n        ]\n        # Add user-specified include dirs\n        for inc in include_dirs:\n            cmd.append(f\"-I{inc}\")\n        cmd += extra_args\n        cmd.append(\"-\")\n\n        with subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        ) as proc:\n            stdout, stderr = proc.communicate(input=code.encode(\"utf-8\"))\n            if proc.returncode != 0:\n                raise RuntimeError(\n                    f\"C preprocessor failed (exit {proc.returncode}): \" f\"{stderr.decode('utf-8', errors='replace')}\"\n                )\n\n        result = stdout.decode(\"utf-8\")\n        return result.replace(\"\\r\\n\", \"\\n\")\n</code></pre>"},{"location":"api/backends/#autopxd.backends.pycparser_backend.PycparserBackend.parse","title":"<code>parse(code, filename, include_dirs=None, extra_args=None)</code>","text":"<p>Parse C code using pycparser.</p> <p>The code is automatically preprocessed using the system's C preprocessor (<code>cpp</code> on Unix/Mac, <code>clang -E</code> on macOS, or <code>cl.exe /E</code> on Windows).</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>C source code to parse.</p> required <code>filename</code> <code>str</code> <p>Source filename for error messages and location tracking.</p> required <code>include_dirs</code> <code>list[str] | None</code> <p>Additional include directories for the preprocessor.</p> <code>None</code> <code>extra_args</code> <code>list[str] | None</code> <p>Extra arguments to pass to the preprocessor.</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>:class:<code>~autopxd.ir.Header</code> containing parsed declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If preprocessing fails.</p> <code>pycparser.plyparser.ParseError</code> <p>If the code has syntax errors.</p> Source code in <code>autopxd/backends/pycparser_backend.py</code> <pre><code>def parse(\n    self,\n    code: str,\n    filename: str,\n    include_dirs: list[str] | None = None,\n    extra_args: list[str] | None = None,\n) -&gt; Header:\n    \"\"\"Parse C code using pycparser.\n\n    The code is automatically preprocessed using the system's C preprocessor\n    (``cpp`` on Unix/Mac, ``clang -E`` on macOS, or ``cl.exe /E`` on Windows).\n\n    :param code: C source code to parse.\n    :param filename: Source filename for error messages and location tracking.\n    :param include_dirs: Additional include directories for the preprocessor.\n    :param extra_args: Extra arguments to pass to the preprocessor.\n    :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n    :raises RuntimeError: If preprocessing fails.\n    :raises pycparser.plyparser.ParseError: If the code has syntax errors.\n    \"\"\"\n    # pylint: disable=import-outside-toplevel\n    from pycparser import (\n        c_parser,\n    )\n\n    # Preprocess the code\n    preprocessed = self._preprocess(code, include_dirs, extra_args)\n\n    parser = c_parser.CParser()\n    ast = parser.parse(preprocessed, filename=filename)\n\n    converter = ASTConverter(filename)\n    return converter.convert(ast)\n</code></pre>"},{"location":"api/backends/#libclang-backend","title":"libclang Backend","text":""},{"location":"api/backends/#autopxd.backends.libclang_backend","title":"<code>libclang_backend</code>","text":"<p>libclang-based parser backend.</p> <p>This backend uses libclang (LLVM's C/C++ parser) to parse header files. It provides full C/C++ support including templates, namespaces, and classes.</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend--requirements","title":"Requirements","text":"<ul> <li>System libclang library must be installed</li> <li>Python clang2 bindings version must match system libclang version   (e.g., <code>clang2==18.*</code> for LLVM 18)</li> </ul> <p>If system libclang is not available, autopxd2 automatically falls back to the pycparser backend (C99 only).</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend--advantages-over-pycparser","title":"Advantages over pycparser","text":"<ul> <li>Full C++ support (classes, templates, namespaces)</li> <li>Handles complex preprocessor constructs</li> <li>Uses the same parser as production compilers</li> <li>Better error messages with source locations</li> </ul>"},{"location":"api/backends/#autopxd.backends.libclang_backend--limitations","title":"Limitations","text":"<ul> <li>Macro extraction is limited due to Python bindings constraints</li> <li>Requires system libclang installation</li> </ul>"},{"location":"api/backends/#autopxd.backends.libclang_backend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.libclang_backend import LibclangBackend\n\nbackend = LibclangBackend()\nheader = backend.parse(code, \"myheader.hpp\", extra_args=[\"-std=c++17\"])\n</code></pre>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend","title":"<code>LibclangBackend</code>","text":"<p>Parser backend using libclang.</p> <p>Uses LLVM's libclang to parse C and C++ code. This backend supports the full C++ language including templates, classes, and namespaces.</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend--properties","title":"Properties","text":"<p>name : str     Returns <code>\"libclang\"</code>. supports_macros : bool     Returns <code>False</code> - macro extraction is limited in Python bindings. supports_cpp : bool     Returns <code>True</code> - full C++ support.</p>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends.libclang_backend import LibclangBackend\n\nbackend = LibclangBackend()\n\n# Parse C++ code with specific standard\nheader = backend.parse(\n    code,\n    \"myheader.hpp\",\n    extra_args=[\"-std=c++17\", \"-DDEBUG=1\"]\n)\n</code></pre> Source code in <code>autopxd/backends/libclang_backend.py</code> <pre><code>class LibclangBackend:\n    \"\"\"Parser backend using libclang.\n\n    Uses LLVM's libclang to parse C and C++ code. This backend supports\n    the full C++ language including templates, classes, and namespaces.\n\n    Properties\n    ----------\n    name : str\n        Returns ``\"libclang\"``.\n    supports_macros : bool\n        Returns ``False`` - macro extraction is limited in Python bindings.\n    supports_cpp : bool\n        Returns ``True`` - full C++ support.\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends.libclang_backend import LibclangBackend\n\n        backend = LibclangBackend()\n\n        # Parse C++ code with specific standard\n        header = backend.parse(\n            code,\n            \"myheader.hpp\",\n            extra_args=[\"-std=c++17\", \"-DDEBUG=1\"]\n        )\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._index: clang.cindex.Index | None = None\n\n    @property\n    def name(self) -&gt; str:\n        return \"libclang\"\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        # Supports simple numeric macros (#define NAME 123)\n        # Complex macros (expressions, function-like) are not supported\n        return True\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        return True\n\n    def _get_index(self) -&gt; \"clang.cindex.Index\":\n        \"\"\"Get or create the clang index.\"\"\"\n        if self._index is None:\n            self._index = clang.cindex.Index.create()\n        return self._index\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: list[str] | None = None,\n        extra_args: list[str] | None = None,\n    ) -&gt; Header:\n        \"\"\"Parse C/C++ code using libclang.\n\n        Unlike the pycparser backend, this method handles raw (unpreprocessed)\n        code and performs preprocessing internally.\n\n        :param code: C/C++ source code to parse (raw, not preprocessed).\n        :param filename: Source filename for error messages and location tracking.\n        :param include_dirs: Additional include directories (converted to ``-I`` flags).\n        :param extra_args: Additional compiler arguments (e.g., ``[\"-std=c++17\"]``).\n        :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n        :raises RuntimeError: If parsing fails with errors.\n\n        Example\n        -------\n        ::\n\n            header = backend.parse(\n                code,\n                \"myheader.hpp\",\n                include_dirs=[\"/usr/local/include\"],\n                extra_args=[\"-std=c++17\", \"-DNDEBUG\"]\n            )\n        \"\"\"\n        args: list[str] = []\n\n        # Add include directories\n        if include_dirs:\n            for inc_dir in include_dirs:\n                args.append(f\"-I{inc_dir}\")\n\n        # Add extra arguments\n        if extra_args:\n            args.extend(extra_args)\n\n        # Parse the code with detailed preprocessing record for macro extraction\n        index = self._get_index()\n        tu = index.parse(\n            filename,\n            args=args,\n            unsaved_files=[(filename, code)],\n            options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD,\n        )\n\n        # Check for fatal errors\n        for diag in tu.diagnostics:\n            if diag.severity &gt;= clang.cindex.Diagnostic.Error:\n                raise RuntimeError(f\"Parse error: {diag.spelling}\")\n\n        # Collect included headers\n        included_headers: set[str] = set()\n        for inclusion in tu.get_includes():\n            # inclusion.include is a File with name attribute\n            header_path = str(inclusion.include.name)\n            # Store full path - caller can extract basename if needed\n            included_headers.add(header_path)\n\n        # Convert to IR\n        converter = ClangASTConverter(filename)\n        header = converter.convert(tu)\n\n        # Attach included headers to the IR\n        header.included_headers = included_headers\n\n        return header\n</code></pre>"},{"location":"api/backends/#autopxd.backends.libclang_backend.LibclangBackend.parse","title":"<code>parse(code, filename, include_dirs=None, extra_args=None)</code>","text":"<p>Parse C/C++ code using libclang.</p> <p>Unlike the pycparser backend, this method handles raw (unpreprocessed) code and performs preprocessing internally.</p> <p>::</p> <pre><code>header = backend.parse(\n    code,\n    \"myheader.hpp\",\n    include_dirs=[\"/usr/local/include\"],\n    extra_args=[\"-std=c++17\", \"-DNDEBUG\"]\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>C/C++ source code to parse (raw, not preprocessed).</p> required <code>filename</code> <code>str</code> <p>Source filename for error messages and location tracking.</p> required <code>include_dirs</code> <code>list[str] | None</code> <p>Additional include directories (converted to <code>-I</code> flags).</p> <code>None</code> <code>extra_args</code> <code>list[str] | None</code> <p>Additional compiler arguments (e.g., <code>[\"-std=c++17\"]</code>).</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>:class:<code>~autopxd.ir.Header</code> containing parsed declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If parsing fails with errors.  Example -------</p> Source code in <code>autopxd/backends/libclang_backend.py</code> <pre><code>def parse(\n    self,\n    code: str,\n    filename: str,\n    include_dirs: list[str] | None = None,\n    extra_args: list[str] | None = None,\n) -&gt; Header:\n    \"\"\"Parse C/C++ code using libclang.\n\n    Unlike the pycparser backend, this method handles raw (unpreprocessed)\n    code and performs preprocessing internally.\n\n    :param code: C/C++ source code to parse (raw, not preprocessed).\n    :param filename: Source filename for error messages and location tracking.\n    :param include_dirs: Additional include directories (converted to ``-I`` flags).\n    :param extra_args: Additional compiler arguments (e.g., ``[\"-std=c++17\"]``).\n    :returns: :class:`~autopxd.ir.Header` containing parsed declarations.\n    :raises RuntimeError: If parsing fails with errors.\n\n    Example\n    -------\n    ::\n\n        header = backend.parse(\n            code,\n            \"myheader.hpp\",\n            include_dirs=[\"/usr/local/include\"],\n            extra_args=[\"-std=c++17\", \"-DNDEBUG\"]\n        )\n    \"\"\"\n    args: list[str] = []\n\n    # Add include directories\n    if include_dirs:\n        for inc_dir in include_dirs:\n            args.append(f\"-I{inc_dir}\")\n\n    # Add extra arguments\n    if extra_args:\n        args.extend(extra_args)\n\n    # Parse the code with detailed preprocessing record for macro extraction\n    index = self._get_index()\n    tu = index.parse(\n        filename,\n        args=args,\n        unsaved_files=[(filename, code)],\n        options=clang.cindex.TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD,\n    )\n\n    # Check for fatal errors\n    for diag in tu.diagnostics:\n        if diag.severity &gt;= clang.cindex.Diagnostic.Error:\n            raise RuntimeError(f\"Parse error: {diag.spelling}\")\n\n    # Collect included headers\n    included_headers: set[str] = set()\n    for inclusion in tu.get_includes():\n        # inclusion.include is a File with name attribute\n        header_path = str(inclusion.include.name)\n        # Store full path - caller can extract basename if needed\n        included_headers.add(header_path)\n\n    # Convert to IR\n    converter = ClangASTConverter(filename)\n    header = converter.convert(tu)\n\n    # Attach included headers to the IR\n    header.included_headers = included_headers\n\n    return header\n</code></pre>"},{"location":"api/ir/","title":"IR Module","text":"<p>The IR (Intermediate Representation) module provides data structures for representing C/C++ declarations in a parser-agnostic format.</p>"},{"location":"api/ir/#autopxd.ir","title":"<code>ir</code>","text":"<p>Intermediate Representation (IR) for C/C++ declarations.</p> <p>This module defines the IR that all parser backends produce. The writer consumes this IR to generate Cython <code>.pxd</code> files.</p>"},{"location":"api/ir/#autopxd.ir--design-principles","title":"Design Principles","text":"<ul> <li>Parser-agnostic: Works with pycparser, libclang, tree-sitter, etc.</li> <li>Intuitive composition: Types compose naturally   (e.g., <code>const char*</code> becomes <code>Pointer(CType(\"char\", [\"const\"]))</code>)</li> <li>Complete coverage: Represents everything Cython <code>.pxd</code> files can express</li> </ul>"},{"location":"api/ir/#autopxd.ir--type-hierarchy","title":"Type Hierarchy","text":"<p>Type expressions form a recursive structure:</p> <ul> <li>:class:<code>CType</code> - Base C type (<code>int</code>, <code>unsigned long</code>, etc.)</li> <li>:class:<code>Pointer</code> - Pointer to another type (<code>int*</code>, <code>char**</code>)</li> <li>:class:<code>Array</code> - Fixed or flexible array (<code>int[10]</code>, <code>char[]</code>)</li> <li>:class:<code>FunctionPointer</code> - Function pointer type</li> </ul>"},{"location":"api/ir/#autopxd.ir--declaration-types","title":"Declaration Types","text":"<ul> <li>:class:<code>Enum</code> - Enumeration with named constants</li> <li>:class:<code>Struct</code> - Struct or union with fields</li> <li>:class:<code>Function</code> - Function declaration</li> <li>:class:<code>Typedef</code> - Type alias</li> <li>:class:<code>Variable</code> - Global variable</li> <li>:class:<code>Constant</code> - Compile-time constant or macro</li> </ul>"},{"location":"api/ir/#autopxd.ir--example","title":"Example","text":"<p>Parse a header and inspect declarations::</p> <pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir import Struct, Function\n\nbackend = get_backend()\nheader = backend.parse(\"struct Point { int x; int y; };\", \"test.h\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Struct):\n        print(f\"Found struct: {decl.name}\")\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Header","title":"<code>Header</code>  <code>dataclass</code>","text":"<p>Container for a parsed C/C++ header file.</p> <p>This is the top-level result returned by all parser backends. It contains the file path and all extracted declarations.</p> <p>::</p> <pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir import Struct, Function\n\nbackend = get_backend()\nheader = backend.parse(code, \"myheader.h\")\n\nprint(f\"Parsed {len(header.declarations)} declarations from {header.path}\")\n\nfor decl in header.declarations:\n    if isinstance(decl, Function):\n        print(f\"  Function: {decl.name}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the original header file.</p> required <code>declarations</code> <code>list[Declaration]</code> <p>List of extracted declarations (structs, functions, etc.).</p> <code>list()</code> <code>included_headers</code> <code>set[str]</code> <p>Set of header file basenames included by this header (populated by libclang backend only).  Example -------</p> <code>set()</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Header:\n    \"\"\"Container for a parsed C/C++ header file.\n\n    This is the top-level result returned by all parser backends.\n    It contains the file path and all extracted declarations.\n\n    :param path: Path to the original header file.\n    :param declarations: List of extracted declarations (structs, functions, etc.).\n    :param included_headers: Set of header file basenames included by this header\n                             (populated by libclang backend only).\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends import get_backend\n        from autopxd.ir import Struct, Function\n\n        backend = get_backend()\n        header = backend.parse(code, \"myheader.h\")\n\n        print(f\"Parsed {len(header.declarations)} declarations from {header.path}\")\n\n        for decl in header.declarations:\n            if isinstance(decl, Function):\n                print(f\"  Function: {decl.name}\")\n    \"\"\"\n\n    path: str\n    declarations: list[Declaration] = field(default_factory=list)\n    included_headers: set[str] = field(default_factory=set)\n\n    def __str__(self) -&gt; str:\n        return f\"Header({self.path}, {len(self.declarations)} declarations)\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.CType","title":"<code>CType</code>  <code>dataclass</code>","text":"<p>A C type expression representing a base type with optional qualifiers.</p> <p>This is the fundamental building block for all type representations. Qualifiers like <code>const</code>, <code>volatile</code>, <code>unsigned</code> are stored separately from the type name for easier manipulation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The base type name (e.g., <code>\"int\"</code>, <code>\"long\"</code>, <code>\"char\"</code>).</p> required <code>qualifiers</code> <code>list[str]</code> <p>Type qualifiers (e.g., <code>[\"const\"]</code>, <code>[\"unsigned\"]</code>).  Examples -------- Simple types::  int_type = CType(\"int\") unsigned_long = CType(\"long\", [\"unsigned\"]) const_int = CType(\"int\", [\"const\"])  Composite types with pointers::  from autopxd.ir import Pointer  # const char* const_char_ptr = Pointer(CType(\"char\", [\"const\"]))</p> <code>list()</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass CType:\n    \"\"\"A C type expression representing a base type with optional qualifiers.\n\n    This is the fundamental building block for all type representations.\n    Qualifiers like ``const``, ``volatile``, ``unsigned`` are stored separately\n    from the type name for easier manipulation.\n\n    :param name: The base type name (e.g., ``\"int\"``, ``\"long\"``, ``\"char\"``).\n    :param qualifiers: Type qualifiers (e.g., ``[\"const\"]``, ``[\"unsigned\"]``).\n\n    Examples\n    --------\n    Simple types::\n\n        int_type = CType(\"int\")\n        unsigned_long = CType(\"long\", [\"unsigned\"])\n        const_int = CType(\"int\", [\"const\"])\n\n    Composite types with pointers::\n\n        from autopxd.ir import Pointer\n\n        # const char*\n        const_char_ptr = Pointer(CType(\"char\", [\"const\"]))\n    \"\"\"\n\n    name: str\n    qualifiers: list[str] = field(default_factory=list)\n\n    def __str__(self) -&gt; str:\n        if self.qualifiers:\n            return f\"{' '.join(self.qualifiers)} {self.name}\"\n        return self.name\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Pointer","title":"<code>Pointer</code>  <code>dataclass</code>","text":"<p>Pointer to another type.</p> <p>Represents pointer types with optional qualifiers. Pointers can be nested to represent multi-level indirection (e.g., <code>char**</code>).</p> <p>Parameters:</p> Name Type Description Default <code>pointee</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The type being pointed to.</p> required <code>qualifiers</code> <code>list[str]</code> <p>Qualifiers on the pointer itself (e.g., <code>[\"const\"]</code> for a const pointer, not a pointer to const).  Examples -------- Basic pointer::  int_ptr = Pointer(CType(\"int\"))  # int  Pointer to const::  const_char_ptr = Pointer(CType(\"char\", [\"const\"]))  # const char  Double pointer::  char_ptr_ptr = Pointer(Pointer(CType(\"char\")))  # char*  Const pointer (pointer itself is const)::  const_ptr = Pointer(CType(\"int\"), [\"const\"])  # int const</p> <code>list()</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Pointer:\n    \"\"\"Pointer to another type.\n\n    Represents pointer types with optional qualifiers. Pointers can be\n    nested to represent multi-level indirection (e.g., ``char**``).\n\n    :param pointee: The type being pointed to.\n    :param qualifiers: Qualifiers on the pointer itself (e.g., ``[\"const\"]``\n        for a const pointer, not a pointer to const).\n\n    Examples\n    --------\n    Basic pointer::\n\n        int_ptr = Pointer(CType(\"int\"))  # int*\n\n    Pointer to const::\n\n        const_char_ptr = Pointer(CType(\"char\", [\"const\"]))  # const char*\n\n    Double pointer::\n\n        char_ptr_ptr = Pointer(Pointer(CType(\"char\")))  # char**\n\n    Const pointer (pointer itself is const)::\n\n        const_ptr = Pointer(CType(\"int\"), [\"const\"])  # int* const\n    \"\"\"\n\n    pointee: Union[CType, Pointer, Array, FunctionPointer]\n    qualifiers: list[str] = field(default_factory=list)\n\n    def __str__(self) -&gt; str:\n        quals = f\"{' '.join(self.qualifiers)} \" if self.qualifiers else \"\"\n        return f\"{quals}{self.pointee}*\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Array","title":"<code>Array</code>  <code>dataclass</code>","text":"<p>Fixed-size or flexible array type.</p> <p>Represents C array types, which can have a fixed numeric size, a symbolic size (macro or constant), or be flexible (incomplete).</p> <p>Parameters:</p> Name Type Description Default <code>element_type</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The type of array elements.</p> required <code>size</code> <code>Optional[Union[int, str]]</code> <p>Array size - an integer for fixed size, a string for symbolic/expression size (e.g., <code>\"MAX_SIZE\"</code>), or None for flexible/incomplete arrays.  Examples -------- Fixed-size array::  int_arr = Array(CType(\"int\"), 10)  Flexible array (incomplete)::  flex_arr = Array(CType(\"char\"), None)  Symbolic size::  buf = Array(CType(\"char\"), \"BUFFER_SIZE\")  Multi-dimensional array::  matrix = Array(Array(CType(\"int\"), 3), 3)</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Array:\n    \"\"\"Fixed-size or flexible array type.\n\n    Represents C array types, which can have a fixed numeric size,\n    a symbolic size (macro or constant), or be flexible (incomplete).\n\n    :param element_type: The type of array elements.\n    :param size: Array size - an integer for fixed size, a string for\n        symbolic/expression size (e.g., ``\"MAX_SIZE\"``), or None for\n        flexible/incomplete arrays.\n\n    Examples\n    --------\n    Fixed-size array::\n\n        int_arr = Array(CType(\"int\"), 10)\n\n    Flexible array (incomplete)::\n\n        flex_arr = Array(CType(\"char\"), None)\n\n    Symbolic size::\n\n        buf = Array(CType(\"char\"), \"BUFFER_SIZE\")\n\n    Multi-dimensional array::\n\n        matrix = Array(Array(CType(\"int\"), 3), 3)\n    \"\"\"\n\n    element_type: Union[CType, Pointer, Array, FunctionPointer]\n    size: Optional[Union[int, str]] = None  # None = flexible, str = expression\n\n    def __str__(self) -&gt; str:\n        size_str = str(self.size) if self.size is not None else \"\"\n        return f\"{self.element_type}[{size_str}]\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.FunctionPointer","title":"<code>FunctionPointer</code>  <code>dataclass</code>","text":"<p>Function pointer type.</p> <p>Represents a pointer to a function with a specific signature. Used for callbacks, vtables, and function tables.</p> <p>Parameters:</p> Name Type Description Default <code>return_type</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The function's return type.</p> required <code>parameters</code> <code>list[Parameter]</code> <p>List of function parameters.</p> <code>list()</code> <code>is_variadic</code> <code>bool</code> <p>True if the function accepts variable arguments (ends with <code>...</code>).  Examples -------- Simple function pointer::  void_fn = FunctionPointer(CType(\"int\"), [])  # int ()(void)  With parameters::  callback = FunctionPointer( CType(\"void\"), [Parameter(\"data\", Pointer(CType(\"void\")))] )  # void ()(void data)  Variadic function pointer::  printf_fn = FunctionPointer( CType(\"int\"), [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))], is_variadic=True )  # int ()(const char* fmt, ...)</p> <code>False</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass FunctionPointer:\n    \"\"\"Function pointer type.\n\n    Represents a pointer to a function with a specific signature.\n    Used for callbacks, vtables, and function tables.\n\n    :param return_type: The function's return type.\n    :param parameters: List of function parameters.\n    :param is_variadic: True if the function accepts variable arguments\n        (ends with ``...``).\n\n    Examples\n    --------\n    Simple function pointer::\n\n        void_fn = FunctionPointer(CType(\"int\"), [])  # int (*)(void)\n\n    With parameters::\n\n        callback = FunctionPointer(\n            CType(\"void\"),\n            [Parameter(\"data\", Pointer(CType(\"void\")))]\n        )  # void (*)(void* data)\n\n    Variadic function pointer::\n\n        printf_fn = FunctionPointer(\n            CType(\"int\"),\n            [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))],\n            is_variadic=True\n        )  # int (*)(const char* fmt, ...)\n    \"\"\"\n\n    return_type: Union[CType, Pointer, Array, FunctionPointer]\n    parameters: list[Parameter] = field(default_factory=list)\n    is_variadic: bool = False\n\n    def __str__(self) -&gt; str:\n        params = \", \".join(str(p) for p in self.parameters)\n        if self.is_variadic:\n            params = f\"{params}, ...\" if params else \"...\"\n        return f\"{self.return_type} (*)({params})\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Field","title":"<code>Field</code>  <code>dataclass</code>","text":"<p>Struct or union field declaration.</p> <p>Represents a single field within a struct or union definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The field name.</p> required <code>type</code> <code>TypeExpr</code> <p>The field's type expression.  Examples -------- Simple field::  x_field = Field(\"x\", CType(\"int\"))  # int x  Pointer field::  data = Field(\"data\", Pointer(CType(\"void\")))  # void* data  Array field::  buffer = Field(\"buffer\", Array(CType(\"char\"), 256))  # char buffer[256]</p> required Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Field:\n    \"\"\"Struct or union field declaration.\n\n    Represents a single field within a struct or union definition.\n\n    :param name: The field name.\n    :param type: The field's type expression.\n\n    Examples\n    --------\n    Simple field::\n\n        x_field = Field(\"x\", CType(\"int\"))  # int x\n\n    Pointer field::\n\n        data = Field(\"data\", Pointer(CType(\"void\")))  # void* data\n\n    Array field::\n\n        buffer = Field(\"buffer\", Array(CType(\"char\"), 256))  # char buffer[256]\n    \"\"\"\n\n    name: str\n    type: TypeExpr\n\n    def __str__(self) -&gt; str:\n        return f\"{self.type} {self.name}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Parameter","title":"<code>Parameter</code>  <code>dataclass</code>","text":"<p>Function parameter declaration.</p> <p>Represents a single parameter in a function signature. Parameters may be named or anonymous (common in prototypes).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Parameter name, or None for anonymous parameters.</p> required <code>type</code> <code>Union[CType, Pointer, Array, FunctionPointer]</code> <p>The parameter's type expression.  Examples -------- Named parameter::  x_param = Parameter(\"x\", CType(\"int\"))  # int x  Anonymous parameter::  anon = Parameter(None, Pointer(CType(\"void\")))  # void*  Complex type::  callback = Parameter(\"fn\", FunctionPointer(CType(\"void\"), []))</p> required Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Parameter:\n    \"\"\"Function parameter declaration.\n\n    Represents a single parameter in a function signature. Parameters\n    may be named or anonymous (common in prototypes).\n\n    :param name: Parameter name, or None for anonymous parameters.\n    :param type: The parameter's type expression.\n\n    Examples\n    --------\n    Named parameter::\n\n        x_param = Parameter(\"x\", CType(\"int\"))  # int x\n\n    Anonymous parameter::\n\n        anon = Parameter(None, Pointer(CType(\"void\")))  # void*\n\n    Complex type::\n\n        callback = Parameter(\"fn\", FunctionPointer(CType(\"void\"), []))\n    \"\"\"\n\n    name: Optional[str]\n    type: Union[CType, Pointer, Array, FunctionPointer]\n\n    def __str__(self) -&gt; str:\n        if self.name:\n            return f\"{self.type} {self.name}\"\n        return str(self.type)\n</code></pre>"},{"location":"api/ir/#autopxd.ir.EnumValue","title":"<code>EnumValue</code>  <code>dataclass</code>","text":"<p>Single enumeration constant.</p> <p>Represents one named constant within an enum definition.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The constant name.</p> required <code>value</code> <code>Optional[Union[int, str]]</code> <p>The constant's value - an integer for explicit values, a string for expressions (e.g., <code>\"FOO | BAR\"</code>), or None for auto-incremented values.  Examples -------- Explicit value::  red = EnumValue(\"RED\", 0)  Auto-increment (implicit value)::  green = EnumValue(\"GREEN\", None)  # follows previous value  Expression value::  mask = EnumValue(\"MASK\", \"FLAG_A | FLAG_B\")</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass EnumValue:\n    \"\"\"Single enumeration constant.\n\n    Represents one named constant within an enum definition.\n\n    :param name: The constant name.\n    :param value: The constant's value - an integer for explicit values,\n        a string for expressions (e.g., ``\"FOO | BAR\"``), or None\n        for auto-incremented values.\n\n    Examples\n    --------\n    Explicit value::\n\n        red = EnumValue(\"RED\", 0)\n\n    Auto-increment (implicit value)::\n\n        green = EnumValue(\"GREEN\", None)  # follows previous value\n\n    Expression value::\n\n        mask = EnumValue(\"MASK\", \"FLAG_A | FLAG_B\")\n    \"\"\"\n\n    name: str\n    value: Optional[Union[int, str]] = None  # None = auto, str = expression\n\n    def __str__(self) -&gt; str:\n        if self.value is not None:\n            return f\"{self.name} = {self.value}\"\n        return self.name\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Enum","title":"<code>Enum</code>  <code>dataclass</code>","text":"<p>Enumeration declaration.</p> <p>Represents a C enum type with named constants. Enums may be named or anonymous (used in typedefs or inline).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The enum tag name, or None for anonymous enums.</p> required <code>values</code> <code>list[EnumValue]</code> <p>List of enumeration constants.</p> <code>list()</code> <code>is_typedef</code> <code>bool</code> <p>True if this enum came from a typedef declaration.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Named enum::  color = Enum(\"Color\", [ EnumValue(\"RED\", 0), EnumValue(\"GREEN\", 1), EnumValue(\"BLUE\", 2), ])  Anonymous enum (typically used with typedef)::  anon = Enum(None, [EnumValue(\"FLAG_A\", 1), EnumValue(\"FLAG_B\", 2)])</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Enum:\n    \"\"\"Enumeration declaration.\n\n    Represents a C enum type with named constants. Enums may be\n    named or anonymous (used in typedefs or inline).\n\n    :param name: The enum tag name, or None for anonymous enums.\n    :param values: List of enumeration constants.\n    :param is_typedef: True if this enum came from a typedef declaration.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Named enum::\n\n        color = Enum(\"Color\", [\n            EnumValue(\"RED\", 0),\n            EnumValue(\"GREEN\", 1),\n            EnumValue(\"BLUE\", 2),\n        ])\n\n    Anonymous enum (typically used with typedef)::\n\n        anon = Enum(None, [EnumValue(\"FLAG_A\", 1), EnumValue(\"FLAG_B\", 2)])\n    \"\"\"\n\n    name: Optional[str]\n    values: list[EnumValue] = field(default_factory=list)\n    is_typedef: bool = False\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        name_str = self.name or \"(anonymous)\"\n        return f\"enum {name_str}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Struct","title":"<code>Struct</code>  <code>dataclass</code>","text":"<p>Struct or union declaration.</p> <p>Represents a C struct or union type definition. Both use the same IR class with <code>is_union</code> distinguishing between them.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The struct/union tag name, or None for anonymous types.</p> required <code>fields</code> <code>list[Field]</code> <p>List of member fields.</p> <code>list()</code> <code>methods</code> <code>list[Function]</code> <p>List of methods (for C++ classes only).</p> <code>list()</code> <code>is_union</code> <code>bool</code> <p>True for unions, False for structs.</p> <code>False</code> <code>is_cppclass</code> <code>bool</code> <p>True for C++ classes (uses <code>cppclass</code> in Cython).</p> <code>False</code> <code>is_typedef</code> <code>bool</code> <p>True if this came from a typedef declaration.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Simple struct::  point = Struct(\"Point\", [ Field(\"x\", CType(\"int\")), Field(\"y\", CType(\"int\")), ])  Union::  data = Struct(\"Data\", [ Field(\"i\", CType(\"int\")), Field(\"f\", CType(\"float\")), ], is_union=True)  C++ class with method::  widget = Struct(\"Widget\", [ Field(\"width\", CType(\"int\")), ], methods=[ Function(\"resize\", CType(\"void\"), [ Parameter(\"w\", CType(\"int\")), Parameter(\"h\", CType(\"int\")), ]) ], is_cppclass=True)  Anonymous struct::  anon = Struct(None, [Field(\"value\", CType(\"int\"))])</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Struct:\n    \"\"\"Struct or union declaration.\n\n    Represents a C struct or union type definition. Both use the same\n    IR class with ``is_union`` distinguishing between them.\n\n    :param name: The struct/union tag name, or None for anonymous types.\n    :param fields: List of member fields.\n    :param methods: List of methods (for C++ classes only).\n    :param is_union: True for unions, False for structs.\n    :param is_cppclass: True for C++ classes (uses ``cppclass`` in Cython).\n    :param is_typedef: True if this came from a typedef declaration.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Simple struct::\n\n        point = Struct(\"Point\", [\n            Field(\"x\", CType(\"int\")),\n            Field(\"y\", CType(\"int\")),\n        ])\n\n    Union::\n\n        data = Struct(\"Data\", [\n            Field(\"i\", CType(\"int\")),\n            Field(\"f\", CType(\"float\")),\n        ], is_union=True)\n\n    C++ class with method::\n\n        widget = Struct(\"Widget\", [\n            Field(\"width\", CType(\"int\")),\n        ], methods=[\n            Function(\"resize\", CType(\"void\"), [\n                Parameter(\"w\", CType(\"int\")),\n                Parameter(\"h\", CType(\"int\")),\n            ])\n        ], is_cppclass=True)\n\n    Anonymous struct::\n\n        anon = Struct(None, [Field(\"value\", CType(\"int\"))])\n    \"\"\"\n\n    name: Optional[str]\n    fields: list[Field] = field(default_factory=list)\n    methods: list[Function] = field(default_factory=list)\n    is_union: bool = False\n    is_cppclass: bool = False\n    is_typedef: bool = False\n    namespace: Optional[str] = None\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        if self.is_cppclass:\n            kind = \"cppclass\"\n        elif self.is_union:\n            kind = \"union\"\n        else:\n            kind = \"struct\"\n        name_str = self.name or \"(anonymous)\"\n        return f\"{kind} {name_str}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Function","title":"<code>Function</code>  <code>dataclass</code>","text":"<p>Function declaration.</p> <p>Represents a C function prototype or declaration. Does not include the function body (declarations only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The function name.</p> required <code>return_type</code> <code>TypeExpr</code> <p>The function's return type.</p> required <code>parameters</code> <code>list[Parameter]</code> <p>List of function parameters.</p> <code>list()</code> <code>is_variadic</code> <code>bool</code> <p>True if the function accepts variable arguments.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Simple function::  exit_fn = Function(\"exit\", CType(\"void\"), [ Parameter(\"status\", CType(\"int\")) ])  With return value::  strlen_fn = Function(\"strlen\", CType(\"size_t\"), [ Parameter(\"s\", Pointer(CType(\"char\", [\"const\"]))) ])  Variadic function::  printf_fn = Function( \"printf\", CType(\"int\"), [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))], is_variadic=True )</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Function:\n    \"\"\"Function declaration.\n\n    Represents a C function prototype or declaration. Does not include\n    the function body (declarations only).\n\n    :param name: The function name.\n    :param return_type: The function's return type.\n    :param parameters: List of function parameters.\n    :param is_variadic: True if the function accepts variable arguments.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Simple function::\n\n        exit_fn = Function(\"exit\", CType(\"void\"), [\n            Parameter(\"status\", CType(\"int\"))\n        ])\n\n    With return value::\n\n        strlen_fn = Function(\"strlen\", CType(\"size_t\"), [\n            Parameter(\"s\", Pointer(CType(\"char\", [\"const\"])))\n        ])\n\n    Variadic function::\n\n        printf_fn = Function(\n            \"printf\",\n            CType(\"int\"),\n            [Parameter(\"fmt\", Pointer(CType(\"char\", [\"const\"])))],\n            is_variadic=True\n        )\n    \"\"\"\n\n    name: str\n    return_type: TypeExpr\n    parameters: list[Parameter] = field(default_factory=list)\n    is_variadic: bool = False\n    namespace: Optional[str] = None\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        params = \", \".join(str(p) for p in self.parameters)\n        if self.is_variadic:\n            params = f\"{params}, ...\" if params else \"...\"\n        return f\"{self.return_type} {self.name}({params})\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Typedef","title":"<code>Typedef</code>  <code>dataclass</code>","text":"<p>Type alias declaration.</p> <p>Represents a C typedef that creates an alias for another type. Common patterns include aliasing primitives, struct tags, and function pointer types.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new type name being defined.</p> required <code>underlying_type</code> <code>TypeExpr</code> <p>The type being aliased.</p> required <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Simple alias::  size_t = Typedef(\"size_t\", CType(\"long\", [\"unsigned\"]))  Struct typedef::  point_t = Typedef(\"Point\", CType(\"struct Point\"))  Function pointer typedef::  callback_t = Typedef(\"Callback\", FunctionPointer( CType(\"void\"), [Parameter(\"data\", Pointer(CType(\"void\")))] ))</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Typedef:\n    \"\"\"Type alias declaration.\n\n    Represents a C typedef that creates an alias for another type.\n    Common patterns include aliasing primitives, struct tags, and\n    function pointer types.\n\n    :param name: The new type name being defined.\n    :param underlying_type: The type being aliased.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Simple alias::\n\n        size_t = Typedef(\"size_t\", CType(\"long\", [\"unsigned\"]))\n\n    Struct typedef::\n\n        point_t = Typedef(\"Point\", CType(\"struct Point\"))\n\n    Function pointer typedef::\n\n        callback_t = Typedef(\"Callback\", FunctionPointer(\n            CType(\"void\"),\n            [Parameter(\"data\", Pointer(CType(\"void\")))]\n        ))\n    \"\"\"\n\n    name: str\n    underlying_type: TypeExpr\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        return f\"typedef {self.underlying_type} {self.name}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Variable","title":"<code>Variable</code>  <code>dataclass</code>","text":"<p>Global variable declaration.</p> <p>Represents a global or extern variable declaration. Does not include local variables (which are not exposed in header files).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The variable name.</p> required <code>type</code> <code>TypeExpr</code> <p>The variable's type.</p> required <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Extern variable::  errno_var = Variable(\"errno\", CType(\"int\"))  Const string::  version = Variable(\"version\", Pointer(CType(\"char\", [\"const\"])))  Array variable::  lookup_table = Variable(\"table\", Array(CType(\"int\"), 256))</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Variable:\n    \"\"\"Global variable declaration.\n\n    Represents a global or extern variable declaration. Does not\n    include local variables (which are not exposed in header files).\n\n    :param name: The variable name.\n    :param type: The variable's type.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Extern variable::\n\n        errno_var = Variable(\"errno\", CType(\"int\"))\n\n    Const string::\n\n        version = Variable(\"version\", Pointer(CType(\"char\", [\"const\"])))\n\n    Array variable::\n\n        lookup_table = Variable(\"table\", Array(CType(\"int\"), 256))\n    \"\"\"\n\n    name: str\n    type: TypeExpr\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        return f\"{self.type} {self.name}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.Constant","title":"<code>Constant</code>  <code>dataclass</code>","text":"<p>Compile-time constant declaration.</p> <p>Represents <code>#define</code> macros with constant values or <code>const</code> variable declarations. Only backends that support macro extraction (e.g., libclang) can populate macro constants.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The constant name.</p> required <code>value</code> <code>Optional[Union[int, float, str]]</code> <p>The constant's value - an integer, float, or string expression. None if the value cannot be determined.</p> <code>None</code> <code>type</code> <code>Optional[CType]</code> <p>For typed constants (<code>const int</code>), the C type. None for macros.</p> <code>None</code> <code>is_macro</code> <code>bool</code> <p>True if this is a <code>#define</code> macro, False for <code>const</code> declarations.</p> <code>False</code> <code>location</code> <code>Optional[SourceLocation]</code> <p>Source location for error reporting.  Examples -------- Numeric macro::  size = Constant(\"SIZE\", 100, is_macro=True)  Expression macro::  mask = Constant(\"MASK\", \"1 &lt;&lt; 4\", is_macro=True)  Typed const::  max_val = Constant(\"MAX_VALUE\", 255, type=CType(\"int\"))  String macro::  version = Constant(\"VERSION\", '\"1.0.0\"', is_macro=True)</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass Constant:\n    \"\"\"Compile-time constant declaration.\n\n    Represents ``#define`` macros with constant values or ``const``\n    variable declarations. Only backends that support macro extraction\n    (e.g., libclang) can populate macro constants.\n\n    :param name: The constant name.\n    :param value: The constant's value - an integer, float, or string\n        expression. None if the value cannot be determined.\n    :param type: For typed constants (``const int``), the C type.\n        None for macros.\n    :param is_macro: True if this is a ``#define`` macro, False for\n        ``const`` declarations.\n    :param location: Source location for error reporting.\n\n    Examples\n    --------\n    Numeric macro::\n\n        size = Constant(\"SIZE\", 100, is_macro=True)\n\n    Expression macro::\n\n        mask = Constant(\"MASK\", \"1 &lt;&lt; 4\", is_macro=True)\n\n    Typed const::\n\n        max_val = Constant(\"MAX_VALUE\", 255, type=CType(\"int\"))\n\n    String macro::\n\n        version = Constant(\"VERSION\", '\"1.0.0\"', is_macro=True)\n    \"\"\"\n\n    name: str\n    value: Optional[Union[int, float, str]] = None  # None if complex/unknown\n    type: Optional[CType] = None\n    is_macro: bool = False\n    location: Optional[SourceLocation] = None\n\n    def __str__(self) -&gt; str:\n        if self.is_macro:\n            return f\"#define {self.name} {self.value}\"\n        return f\"const {self.type} {self.name} = {self.value}\"\n</code></pre>"},{"location":"api/ir/#autopxd.ir.SourceLocation","title":"<code>SourceLocation</code>  <code>dataclass</code>","text":"<p>Location in source file for error reporting and filtering.</p> <p>Used to track where declarations originated, enabling:</p> <ul> <li>Better error messages during parsing</li> <li>Filtering declarations by file (e.g., exclude system headers)</li> <li>Source mapping for debugging</li> </ul> <p>::</p> <pre><code>loc = SourceLocation(\"myheader.h\", 42, 5)\nprint(f\"Declaration at {loc.file}:{loc.line}\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>Path to the source file.</p> required <code>line</code> <code>int</code> <p>Line number (1-indexed).</p> required <code>column</code> <code>Optional[int]</code> <p>Column number (1-indexed), or None if unknown.  Example -------</p> <code>None</code> Source code in <code>autopxd/ir.py</code> <pre><code>@dataclass\nclass SourceLocation:\n    \"\"\"Location in source file for error reporting and filtering.\n\n    Used to track where declarations originated, enabling:\n\n    * Better error messages during parsing\n    * Filtering declarations by file (e.g., exclude system headers)\n    * Source mapping for debugging\n\n    :param file: Path to the source file.\n    :param line: Line number (1-indexed).\n    :param column: Column number (1-indexed), or None if unknown.\n\n    Example\n    -------\n    ::\n\n        loc = SourceLocation(\"myheader.h\", 42, 5)\n        print(f\"Declaration at {loc.file}:{loc.line}\")\n    \"\"\"\n\n    file: str\n    line: int\n    column: Optional[int] = None\n</code></pre>"},{"location":"api/ir/#autopxd.ir.ParserBackend","title":"<code>ParserBackend</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol defining the interface for parser backends.</p> <p>All parser backends must implement this protocol to be usable with autopxd2. Backends are responsible for translating from their native AST format (pycparser, libclang, etc.) to the common :class:<code>Header</code> IR format.</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend--available-backends","title":"Available Backends","text":"<ul> <li><code>pycparser</code> - Pure Python C99 parser (default)</li> <li><code>libclang</code> - LLVM clang-based parser with C++ support</li> </ul>"},{"location":"api/ir/#autopxd.ir.ParserBackend--example","title":"Example","text":"<p>::</p> <pre><code>from autopxd.backends import get_backend\n\n# Get default backend\nbackend = get_backend()\n\n# Get specific backend\nlibclang = get_backend(\"libclang\")\n\n# Parse code\nheader = backend.parse(\"int foo(void);\", \"test.h\")\n</code></pre> Source code in <code>autopxd/ir.py</code> <pre><code>class ParserBackend(Protocol):  # pylint: disable=too-few-public-methods\n    \"\"\"Protocol defining the interface for parser backends.\n\n    All parser backends must implement this protocol to be usable with autopxd2.\n    Backends are responsible for translating from their native AST format\n    (pycparser, libclang, etc.) to the common :class:`Header` IR format.\n\n    Available Backends\n    ------------------\n    * ``pycparser`` - Pure Python C99 parser (default)\n    * ``libclang`` - LLVM clang-based parser with C++ support\n\n    Example\n    -------\n    ::\n\n        from autopxd.backends import get_backend\n\n        # Get default backend\n        backend = get_backend()\n\n        # Get specific backend\n        libclang = get_backend(\"libclang\")\n\n        # Parse code\n        header = backend.parse(\"int foo(void);\", \"test.h\")\n    \"\"\"\n\n    # pylint: disable=unnecessary-ellipsis\n\n    def parse(\n        self,\n        code: str,\n        filename: str,\n        include_dirs: Optional[list[str]] = None,\n        extra_args: Optional[list[str]] = None,\n    ) -&gt; Header:\n        \"\"\"Parse C/C++ code and return the IR representation.\n\n        :param code: Source code to parse.\n        :param filename: Name of the source file. Used for error messages\n            and ``#line`` directives. Does not need to exist on disk.\n        :param include_dirs: Directories to search for ``#include`` files.\n            Only used by backends that handle preprocessing.\n        :param extra_args: Additional arguments for the preprocessor/compiler.\n            Format is backend-specific.\n        :returns: Parsed header containing all extracted declarations.\n        :raises RuntimeError: If parsing fails due to syntax errors.\n        \"\"\"\n        ...\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Human-readable name of this backend (e.g., ``\"pycparser\"``).\"\"\"\n        ...\n\n    @property\n    def supports_macros(self) -&gt; bool:\n        \"\"\"Whether this backend can extract ``#define`` constants.\"\"\"\n        ...\n\n    @property\n    def supports_cpp(self) -&gt; bool:\n        \"\"\"Whether this backend can parse C++ code.\"\"\"\n        ...\n</code></pre>"},{"location":"api/ir/#autopxd.ir.ParserBackend.name","title":"<code>name</code>  <code>property</code>","text":"<p>Human-readable name of this backend (e.g., <code>\"pycparser\"</code>).</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend.supports_macros","title":"<code>supports_macros</code>  <code>property</code>","text":"<p>Whether this backend can extract <code>#define</code> constants.</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend.supports_cpp","title":"<code>supports_cpp</code>  <code>property</code>","text":"<p>Whether this backend can parse C++ code.</p>"},{"location":"api/ir/#autopxd.ir.ParserBackend.parse","title":"<code>parse(code, filename, include_dirs=None, extra_args=None)</code>","text":"<p>Parse C/C++ code and return the IR representation.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Source code to parse.</p> required <code>filename</code> <code>str</code> <p>Name of the source file. Used for error messages and <code>#line</code> directives. Does not need to exist on disk.</p> required <code>include_dirs</code> <code>Optional[list[str]]</code> <p>Directories to search for <code>#include</code> files. Only used by backends that handle preprocessing.</p> <code>None</code> <code>extra_args</code> <code>Optional[list[str]]</code> <p>Additional arguments for the preprocessor/compiler. Format is backend-specific.</p> <code>None</code> <p>Returns:</p> Type Description <code>Header</code> <p>Parsed header containing all extracted declarations.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If parsing fails due to syntax errors.</p> Source code in <code>autopxd/ir.py</code> <pre><code>def parse(\n    self,\n    code: str,\n    filename: str,\n    include_dirs: Optional[list[str]] = None,\n    extra_args: Optional[list[str]] = None,\n) -&gt; Header:\n    \"\"\"Parse C/C++ code and return the IR representation.\n\n    :param code: Source code to parse.\n    :param filename: Name of the source file. Used for error messages\n        and ``#line`` directives. Does not need to exist on disk.\n    :param include_dirs: Directories to search for ``#include`` files.\n        Only used by backends that handle preprocessing.\n    :param extra_args: Additional arguments for the preprocessor/compiler.\n        Format is backend-specific.\n    :returns: Parsed header containing all extracted declarations.\n    :raises RuntimeError: If parsing fails due to syntax errors.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"getting-started/docker/","title":"Docker Usage","text":"<p>autopxd2 provides a Docker image with libclang pre-installed, allowing you to generate high-quality <code>.pxd</code> files without installing clang on your system.</p> <p>Recommended for C++ headers</p> <p>The Docker image is the easiest way to use the libclang backend, which provides better C++ support and handles complex headers that pycparser cannot parse.</p>"},{"location":"getting-started/docker/#quick-start","title":"Quick Start","text":"<pre><code># Build the Docker image\ndocker build -t autopxd2 https://github.com/elijahr/python-autopxd2.git\n\n# Or build from local checkout\ngit clone https://github.com/elijahr/python-autopxd2.git\ncd python-autopxd2\ndocker build -t autopxd2 .\n</code></pre>"},{"location":"getting-started/docker/#usage-examples","title":"Usage Examples","text":""},{"location":"getting-started/docker/#generate-pxd-from-a-header-file","title":"Generate pxd from a header file","text":"<pre><code># Mount your project directory and generate pxd\ndocker run --rm -v $(pwd):/work autopxd2 autopxd /work/myheader.h\n\n# Save output to a file\ndocker run --rm -v $(pwd):/work autopxd2 autopxd /work/myheader.h &gt; myheader.pxd\n</code></pre>"},{"location":"getting-started/docker/#use-libclang-backend","title":"Use libclang backend","text":"<pre><code># Explicitly use libclang for better C++ support\ndocker run --rm -v $(pwd):/work autopxd2 autopxd --backend libclang /work/myheader.hpp\n</code></pre>"},{"location":"getting-started/docker/#include-directories","title":"Include directories","text":"<pre><code># Add include paths for dependent headers\ndocker run --rm -v $(pwd):/work autopxd2 autopxd \\\n    -I /work/include \\\n    -I /work/third_party \\\n    /work/src/myheader.h\n</code></pre>"},{"location":"getting-started/docker/#interactive-shell","title":"Interactive shell","text":"<pre><code># Get an interactive shell in the container\ndocker run --rm -it -v $(pwd):/work autopxd2 bash\n\n# Then run autopxd commands interactively\nautopxd /work/myheader.h\n</code></pre>"},{"location":"getting-started/docker/#docker-compose","title":"Docker Compose","text":"<p>For projects that frequently use autopxd2, add it to your <code>docker-compose.yml</code>:</p> <pre><code>services:\n  autopxd:\n    build: https://github.com/elijahr/python-autopxd2.git\n    volumes:\n      - .:/work\n    working_dir: /work\n</code></pre> <p>Then run:</p> <pre><code>docker compose run --rm autopxd autopxd myheader.h\n</code></pre>"},{"location":"getting-started/docker/#whats-included","title":"What's Included","text":"<p>The Docker image includes:</p> <ul> <li>Python 3.12</li> <li>clang and libclang development libraries</li> <li>autopxd2 with all dependencies</li> <li>The <code>clang</code> Python package for libclang bindings</li> </ul>"},{"location":"getting-started/docker/#building-for-different-architectures","title":"Building for Different Architectures","text":"<p>The Dockerfile supports both AMD64 and ARM64 architectures:</p> <pre><code># Build for current architecture\ndocker build -t autopxd2 .\n\n# Build for specific architecture\ndocker build --platform linux/amd64 -t autopxd2:amd64 .\ndocker build --platform linux/arm64 -t autopxd2:arm64 .\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#basic-installation","title":"Basic Installation","text":"<p>Install autopxd2 from PyPI:</p> <pre><code>pip install autopxd2\n</code></pre> <p>This installs the package with both parser backends:</p> <ul> <li>libclang - Full C/C++ support via LLVM (default if system libclang available)</li> <li>pycparser - Pure Python C99 parser (fallback)</li> </ul> <p>Automatic Fallback</p> <p>autopxd2 automatically uses libclang if the system library is available, falling back to pycparser otherwise. Use <code>autopxd --list-backends</code> to see which backends are available on your system.</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development, clone the repository and install with development dependencies:</p> <pre><code>git clone https://github.com/elijahr/python-autopxd2.git\ncd python-autopxd2\npip install -e .[dev]\n</code></pre>"},{"location":"getting-started/installation/#docker-no-installation-required","title":"Docker (No Installation Required)","text":"<p>Use the Docker image for libclang support without installing anything locally:</p> <pre><code>docker build -t autopxd2 https://github.com/elijahr/python-autopxd2.git\ndocker run --rm -v $(pwd):/work autopxd2 autopxd /work/myheader.h\n</code></pre> <p>See Docker Usage for more details.</p>"},{"location":"getting-started/installation/#system-libclang-installation","title":"System libclang Installation","text":"<p>The libclang backend requires both:</p> <ol> <li>The system libclang library</li> <li>The Python <code>clang2</code> package (included with autopxd2)</li> </ol> <p>Version Matching Required</p> <p>The Python <code>clang2</code> package provides libclang bindings and must match your system's libclang version. For example, if you have LLVM 18 installed, you need <code>clang2==18.*</code>.</p> <pre><code># Check your LLVM version\nllvm-config --version  # e.g., 18.1.3\n\n# Install matching Python package\npip install \"clang2==18.*\"\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code>brew install llvm\n\n# Install matching Python clang2 package\nLLVM_VERSION=$($(brew --prefix llvm)/bin/llvm-config --version | cut -d. -f1)\npip install \"clang2==${LLVM_VERSION}.*\"\n</code></pre>"},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt-get install libclang-dev llvm\n\n# Install matching Python clang2 package\nLLVM_VERSION=$(llvm-config --version | cut -d. -f1)\npip install \"clang2==${LLVM_VERSION}.*\"\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<ol> <li>Install LLVM from releases.llvm.org</li> <li>Add LLVM to your PATH</li> <li>Install matching Python clang2 package: <code>pip install \"clang2==&lt;version&gt;.*\"</code></li> </ol>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>Check that autopxd2 can find libclang:</p> <pre><code>autopxd --list-backends\n</code></pre> <p>If libclang is installed correctly, you should see:</p> <pre><code>Available backends:\n  libclang     Full C/C++ support via LLVM [available] (default)\n  pycparser    Legacy C99 parser [available]\n\nDefault: libclang\n</code></pre>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>This guide will get you generating Cython <code>.pxd</code> files in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#basic-usage","title":"Basic Usage","text":"<p>Given a C header file <code>example.h</code>:</p> <pre><code>// example.h\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nPoint create_point(int x, int y);\ndouble distance(Point a, Point b);\n</code></pre> <p>Generate a <code>.pxd</code> file:</p> <pre><code>autopxd example.h &gt; example.pxd\n</code></pre> <p>This produces:</p> <pre><code>cdef extern from \"example.h\":\n\n    cdef struct Point:\n        int x\n        int y\n\n    Point create_point(int x, int y)\n\n    double distance(Point a, Point b)\n</code></pre>"},{"location":"getting-started/quickstart/#include-directories","title":"Include Directories","text":"<p>If your header includes other headers, specify include directories:</p> <pre><code>autopxd -I /path/to/includes myheader.h\n</code></pre>"},{"location":"getting-started/quickstart/#choosing-a-backend","title":"Choosing a Backend","text":"<p>autopxd2 supports two parser backends:</p> Backend Best For Requirements pycparser Simple C headers None (pure Python) libclang C++ headers, complex macros libclang installed <p>Use the <code>--backend</code> option:</p> <pre><code># Use pycparser (default)\nautopxd --backend pycparser myheader.h\n\n# Use libclang for C++ support\nautopxd --backend libclang myheader.hpp\n</code></pre>"},{"location":"getting-started/quickstart/#using-with-cython","title":"Using with Cython","text":"<p>After generating the <code>.pxd</code> file, use it in your Cython code:</p> <pre><code># mymodule.pyx\nfrom example cimport Point, create_point, distance\n\ndef make_point(x: int, y: int) -&gt; tuple:\n    cdef Point p = create_point(x, y)\n    return (p.x, p.y)\n\ndef calc_distance(p1: tuple, p2: tuple) -&gt; float:\n    cdef Point a, b\n    a.x, a.y = p1\n    b.x, b.y = p2\n    return distance(a, b)\n</code></pre>"},{"location":"getting-started/quickstart/#python-api","title":"Python API","text":"<p>You can also use autopxd2 programmatically:</p> <pre><code>from autopxd.backends import get_backend\nfrom autopxd.ir_writer import write_pxd\n\n# Parse a header file\nbackend = get_backend(\"pycparser\")  # or \"libclang\"\nwith open(\"example.h\") as f:\n    code = f.read()\n\nheader = backend.parse(code, \"example.h\")\n\n# Generate pxd content\npxd = write_pxd(header)\nprint(pxd)\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Parser Backends - Learn about backend differences</li> <li>C++ Support - Working with C++ headers</li> <li>Docker Usage - Use Docker for libclang without local installation</li> </ul>"},{"location":"user-guide/backends/","title":"Parser Backends","text":"<p>autopxd2 supports multiple parser backends for converting C/C++ headers to Cython declarations.</p>"},{"location":"user-guide/backends/#available-backends","title":"Available Backends","text":""},{"location":"user-guide/backends/#pycparser-default","title":"pycparser (Default)","text":"<p>A pure Python C99 parser. Works out of the box with no external dependencies.</p> <p>Pros:</p> <ul> <li>No external dependencies</li> <li>Works on all platforms</li> <li>Fast for simple headers</li> </ul> <p>Cons:</p> <ul> <li>C99 only (no C++ support)</li> <li>Requires preprocessed code (no comments or macros in input)</li> <li>May struggle with complex headers</li> </ul> <p>Usage:</p> <pre><code>autopxd --backend pycparser myheader.h\n</code></pre>"},{"location":"user-guide/backends/#libclang","title":"libclang","text":"<p>Uses LLVM's clang library for parsing. Provides the same parser used by actual compilers.</p> <p>Pros:</p> <ul> <li>Full C++ support (classes, templates, namespaces)</li> <li>Extracts simple numeric macros as constants</li> <li>Handles comments and preprocessor directives directly</li> <li>Better error messages</li> <li>Handles complex headers reliably</li> </ul> <p>Cons:</p> <ul> <li>Requires libclang to be installed</li> <li>Python <code>clang2</code> package version must match system libclang (these are official LLVM bindings)</li> <li>Slightly slower startup time</li> <li>Complex macros (expressions, function-like) are not extracted</li> </ul> <p>Usage:</p> <pre><code>autopxd --backend libclang myheader.h\n\n# For C++ headers\nautopxd --backend libclang myheader.hpp\n</code></pre>"},{"location":"user-guide/backends/#choosing-a-backend","title":"Choosing a Backend","text":"Use Case Recommended Backend Simple C headers pycparser C++ headers libclang Headers with complex macros libclang Cross-platform without dependencies pycparser Production use with complex libraries libclang"},{"location":"user-guide/backends/#backend-comparison","title":"Backend Comparison","text":"<p>Both backends produce equivalent output for standard C constructs:</p> <pre><code>// input.h\nstruct Point {\n    int x;\n    int y;\n};\n\nint distance(struct Point a, struct Point b);\n</code></pre> <p>Both backends produce:</p> <pre><code>cdef extern from \"input.h\":\n\n    cdef struct Point:\n        int x\n        int y\n\n    int distance(Point a, Point b)\n</code></pre>"},{"location":"user-guide/backends/#macro-extraction-libclang-only","title":"Macro Extraction (libclang only)","text":"<p>The libclang backend extracts <code>#define</code> macros as Cython constant declarations. The type is automatically detected from the macro value.</p>"},{"location":"user-guide/backends/#integer-macros","title":"Integer Macros","text":"<pre><code>#define SIZE 100\n#define MASK 0xFF\n#define MODE 0755\n#define FLAGS 0b1010\n#define BIG_NUM 100ULL\n</code></pre> <p>Generates <code>int</code> declarations:</p> <pre><code>    int SIZE\n    int MASK\n    int MODE\n    int FLAGS\n    int BIG_NUM\n</code></pre> <p>Supported formats: decimal, hex (<code>0x</code>), octal (<code>0</code>), binary (<code>0b</code>), with optional type suffixes (<code>U</code>, <code>L</code>, <code>UL</code>, <code>LL</code>, <code>ULL</code>).</p>"},{"location":"user-guide/backends/#floating-point-macros","title":"Floating-Point Macros","text":"<pre><code>#define PI 3.14159\n#define EPSILON 1e-10\n#define FACTOR 2.5f\n</code></pre> <p>Generates <code>double</code> declarations:</p> <pre><code>    double PI\n    double EPSILON\n    double FACTOR\n</code></pre>"},{"location":"user-guide/backends/#string-macros","title":"String Macros","text":"<pre><code>#define VERSION \"1.0.0\"\n#define APP_NAME \"myapp\"\n</code></pre> <p>Generates <code>const char*</code> declarations:</p> <pre><code>    const char* VERSION\n    const char* APP_NAME\n</code></pre>"},{"location":"user-guide/backends/#expression-macros","title":"Expression Macros","text":"<pre><code>#define A 10\n#define B 20\n#define TOTAL (A + B)\n#define FLAGS (0x01 | 0x02)\n#define NEGATIVE -1\n</code></pre> <p>Expression macros that consist of numeric literals, operators, and other macro references are detected and declared with appropriate types:</p> <pre><code>    int A\n    int B\n    int TOTAL\n    int FLAGS\n    int NEGATIVE\n</code></pre>"},{"location":"user-guide/backends/#unsupported-macros-silently-ignored","title":"Unsupported Macros (silently ignored)","text":"<ul> <li>Function-like macros: <code>#define MAX(a, b) ((a) &gt; (b) ? (a) : (b))</code></li> <li>Empty macros: <code>#define EMPTY</code></li> <li>String concatenation: <code>#define CONCAT \"hello\" \"world\"</code></li> </ul> <p>The pycparser backend does not extract macros since it requires preprocessed input.</p>"},{"location":"user-guide/backends/#using-docker-for-libclang","title":"Using Docker for libclang","text":"<p>If you don't want to install libclang locally, use the Docker image:</p> <pre><code>docker run --rm -v $(pwd):/work autopxd2 autopxd --backend libclang /work/myheader.h\n</code></pre> <p>See Docker Usage for details.</p>"},{"location":"user-guide/backends/#programmatic-backend-selection","title":"Programmatic Backend Selection","text":"<pre><code>from autopxd.backends import get_backend, list_backends\n\n# List available backends\nprint(list_backends())  # ['pycparser', 'libclang'] (if libclang installed)\n\n# Get a specific backend\nbackend = get_backend(\"libclang\")\n\n# Parse a header\nheader = backend.parse(code, \"myheader.h\")\n</code></pre>"},{"location":"user-guide/cli/","title":"CLI Reference","text":"<p>The <code>autopxd</code> command-line tool generates Cython <code>.pxd</code> files from C/C++ headers.</p>"},{"location":"user-guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>autopxd [OPTIONS] [INFILE] [OUTFILE]\n</code></pre>"},{"location":"user-guide/cli/#options","title":"Options","text":""},{"location":"user-guide/cli/#-v-version","title":"<code>-v, --version</code>","text":"<p>Print program version and exit.</p> <pre><code>autopxd --version\n</code></pre>"},{"location":"user-guide/cli/#-b-backend-name","title":"<code>-b, --backend &lt;name&gt;</code>","text":"<p>Select the parser backend. Options: <code>auto</code> (default), <code>libclang</code>, <code>pycparser</code>.</p> <ul> <li><code>auto</code>: Use libclang if available, fall back to pycparser</li> <li><code>libclang</code>: Full C/C++ support via LLVM</li> <li><code>pycparser</code>: Legacy C99 parser (no C++ support)</li> </ul> <pre><code>autopxd --backend libclang myheader.hpp\nautopxd -b pycparser myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-list-backends","title":"<code>--list-backends</code>","text":"<p>Show available backends and exit.</p> <pre><code>autopxd --list-backends\n</code></pre>"},{"location":"user-guide/cli/#-json","title":"<code>--json</code>","text":"<p>Output in JSON format (for use with <code>--list-backends</code>).</p> <pre><code>autopxd --list-backends --json\n</code></pre>"},{"location":"user-guide/cli/#-x-cpp","title":"<code>-x, --cpp</code>","text":"<p>Parse as C++ (requires libclang backend).</p> <pre><code>autopxd --cpp myclass.hpp\n</code></pre>"},{"location":"user-guide/cli/#-std-standard","title":"<code>--std &lt;standard&gt;</code>","text":"<p>Specify the language standard (requires libclang backend).</p> <pre><code>autopxd --std c11 myheader.h\nautopxd --std c++17 myclass.hpp\n</code></pre>"},{"location":"user-guide/cli/#-i-include-dir-dir","title":"<code>-I, --include-dir &lt;dir&gt;</code>","text":"<p>Add a directory to the include search path. Can be specified multiple times.</p> <pre><code>autopxd -I /usr/include -I ./include myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-d-compiler-directive-directive","title":"<code>-D, --compiler-directive &lt;directive&gt;</code>","text":"<p>Pass a directive to the C preprocessor. Can be specified multiple times.</p> <pre><code>autopxd -D DEBUG -D VERSION=2 myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-r-regex-pattern","title":"<code>-R, --regex &lt;pattern&gt;</code>","text":"<p>Apply a sed-style search/replace pattern after preprocessing. Useful for fixing problematic constructs.</p> <pre><code>autopxd -R 's/__attribute__.*//g' myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-w-whitelist-file","title":"<code>-w, --whitelist &lt;file&gt;</code>","text":"<p>Only generate declarations from specified files. Can be specified multiple times.</p> <pre><code>autopxd -w main.h -w types.h combined.h\n</code></pre>"},{"location":"user-guide/cli/#-clang-arg-arg","title":"<code>--clang-arg &lt;arg&gt;</code>","text":"<p>Pass an argument directly to libclang. Can be specified multiple times.</p> <pre><code>autopxd --clang-arg -DFOO --clang-arg -I/custom/include myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-q-quiet","title":"<code>-q, --quiet</code>","text":"<p>Suppress warnings (e.g., backend fallback warnings).</p> <pre><code>autopxd -q myheader.h\n</code></pre>"},{"location":"user-guide/cli/#-debug-no-debug","title":"<code>--debug / --no-debug</code>","text":"<p>Dump preprocessor output to stderr for debugging.</p> <pre><code>autopxd --debug myheader.h 2&gt;preprocessed.txt\n</code></pre>"},{"location":"user-guide/cli/#-h-help","title":"<code>-h, --help</code>","text":"<p>Show help message and exit.</p> <pre><code>autopxd --help\n</code></pre>"},{"location":"user-guide/cli/#examples","title":"Examples","text":""},{"location":"user-guide/cli/#generate-pxd-from-a-header","title":"Generate pxd from a header","text":"<pre><code>autopxd myheader.h myheader.pxd\n</code></pre>"},{"location":"user-guide/cli/#with-include-directories","title":"With include directories","text":"<pre><code>autopxd -I /opt/local/include -I ./third_party mylib.h mylib.pxd\n</code></pre>"},{"location":"user-guide/cli/#using-libclang-for-c","title":"Using libclang for C++","text":"<pre><code>autopxd --backend libclang --cpp myclass.hpp myclass.pxd\n</code></pre>"},{"location":"user-guide/cli/#using-c17-standard","title":"Using C++17 standard","text":"<pre><code>autopxd -x --std c++17 modern.hpp modern.pxd\n</code></pre>"},{"location":"user-guide/cli/#fix-problematic-macros","title":"Fix problematic macros","text":"<pre><code>autopxd -R 's/__restrict//g' -R 's/__extension__//g' header.h header.pxd\n</code></pre>"},{"location":"user-guide/cli/#check-available-backends","title":"Check available backends","text":"<pre><code>autopxd --list-backends\n</code></pre>"},{"location":"user-guide/cli/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/cli/#libclang-not-available","title":"libclang not available","text":"<p>If you see \"libclang not available, falling back to pycparser\", install the system libclang library:</p> <p>Ubuntu/Debian: <pre><code>apt install libclang-dev\n</code></pre></p> <p>macOS: <pre><code>brew install llvm\n</code></pre></p> <p>Or use Docker: <pre><code>docker run --rm -v $(pwd):/work ghcr.io/elijahr/autopxd2 myheader.h myheader.pxd\n</code></pre></p>"},{"location":"user-guide/cli/#c-parsing-fails","title":"C++ parsing fails","text":"<p>Make sure you're using the libclang backend:</p> <pre><code>autopxd --backend libclang --cpp myheader.hpp\n</code></pre>"},{"location":"user-guide/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Parse error or invalid input 2 Invalid command-line arguments"},{"location":"user-guide/cpp/","title":"C++ Support","text":"<p>autopxd2 supports C++ headers through the libclang backend.</p> <p>Important</p> <p>C++ support requires the libclang backend. The default pycparser backend only supports C99.</p>"},{"location":"user-guide/cpp/#basic-c-usage","title":"Basic C++ Usage","text":"<pre><code># Use libclang for C++ headers\nautopxd --backend libclang myclass.hpp &gt; myclass.pxd\n</code></pre> <p>Or with Docker:</p> <pre><code>docker run --rm -v $(pwd):/work autopxd2 autopxd --backend libclang /work/myclass.hpp\n</code></pre>"},{"location":"user-guide/cpp/#supported-c-features","title":"Supported C++ Features","text":""},{"location":"user-guide/cpp/#classes","title":"Classes","text":"<p>C++ classes are converted to Cython structs:</p> <pre><code>// widget.hpp\nclass Widget {\npublic:\n    int width;\n    int height;\n};\n</code></pre> <p>Generates:</p> <pre><code>cdef extern from \"widget.hpp\":\n\n    cdef struct Widget:\n        int width\n        int height\n</code></pre>"},{"location":"user-guide/cpp/#structs","title":"Structs","text":"<p>C++ structs work the same as C:</p> <pre><code>struct Point {\n    double x;\n    double y;\n};\n</code></pre>"},{"location":"user-guide/cpp/#functions","title":"Functions","text":"<p>Global functions are converted directly:</p> <pre><code>double distance(const Point&amp; a, const Point&amp; b);\n</code></pre> <p>Generates:</p> <pre><code>double distance(const Point &amp; a, const Point &amp; b)\n</code></pre>"},{"location":"user-guide/cpp/#namespaces","title":"Namespaces","text":"<p>Currently, only top-level declarations are extracted. Namespaced declarations are not directly supported.</p>"},{"location":"user-guide/cpp/#limitations","title":"Limitations","text":""},{"location":"user-guide/cpp/#methods","title":"Methods","text":"<p>Class methods are not included in the generated <code>.pxd</code>. Only public data members are extracted.</p> <p>For full method support, you'll need to manually add method declarations or use Cython's <code>cppclass</code> syntax.</p>"},{"location":"user-guide/cpp/#templates","title":"Templates","text":"<p>Template classes and functions are not currently supported.</p>"},{"location":"user-guide/cpp/#overloading","title":"Overloading","text":"<p>Multiple overloaded functions with the same name may produce conflicts. You may need to manually select which overload to use.</p>"},{"location":"user-guide/cpp/#best-practices","title":"Best Practices","text":"<ol> <li>Use header-only libraries where possible for simpler integration</li> <li>Start with the Docker image to avoid libclang installation issues</li> <li>Check generated output and manually adjust for complex C++ features</li> <li>Consider Cython's cppclass for classes with methods you need to call</li> </ol>"},{"location":"user-guide/cpp/#example-workflow","title":"Example Workflow","text":"<ol> <li> <p>Generate initial pxd:    <pre><code>autopxd --backend libclang mylib.hpp &gt; mylib.pxd\n</code></pre></p> </li> <li> <p>Review and adjust for methods, templates, or other features</p> </li> <li> <p>Create your Cython wrapper:    <pre><code># mylib.pyx\nfrom mylib cimport Widget\n\ndef create_widget(width: int, height: int):\n    cdef Widget w\n    w.width = width\n    w.height = height\n    return (w.width, w.height)\n</code></pre></p> </li> </ol>"}]}